{"pages":[{"title":"About","text":"","link":"/about/"},{"title":"Gallery 画廊","text":"🌏颅内世界 以下图片来源于 wallhaven.cc","link":"/gallery/"},{"title":"books","text":"","link":"/books/"},{"title":"Category","text":"","link":"/categories/"},{"title":"Repositories","text":"","link":"/repository/"},{"title":"Tag","text":"","link":"/tags/"},{"title":"share","text":"","link":"/share/"}],"posts":[{"title":"算法&#x2F;回合制战斗","text":"一小道C语言题带来的乐趣 要用游戏的玩法打败游戏的情景题! 对于以下题目： 某游戏规则中，甲乙双方每个回合的战斗总是有一方胜利，一方失败。游戏规定：失败的一方要把自己的体力值的1/4加给胜利的一方。例如：如果双方体力值当前都是4，则经过一轮战斗后，双方的体力值会变为：5，3。现在已知：双方开始时的体力值甲：1000，乙：2000。假设战斗中，甲乙获胜的概率都是50%，求解：双方经过4个回合的战斗，体力值之差小于1000的理论概率。 用基础模拟算法来解决： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define all 16//所有可能的结果数目int exchange(double * x,double * y) //x为吸收血量方 { double t; t=(*y)*0.25;(*x)+=t;(*y)-=t; return 0; } int main(){ int js=0; double x=1000,y=2000; //美好的游戏模拟开始了 for(int i=0;i&lt;=1;i++) { double ax=x,ay=y;//存档，防止数据丢失 i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); //i判断甲（x）是否赢得一回合，并改变血条 for(int i=0;i&lt;=1;i++) { double bx=x,by=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double cx=x,cy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double dx=x,dy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); if(x-y&lt;1000&amp;&amp;x-y&gt;-1000) js++; x=dx;y=dy; //重新读档，开始下一轮模拟 } x=cx;y=cy;//读档，余同 } x=bx;y=by; } x=ax;y=ay; } printf(\"四回合后体力值差&lt;1000的理论概率:\\n%f\",js*1.0/all); return 0;} ==是不是特像打游戏刷关呢?( ^ v ^ )==","link":"/posts/aee17ffb/"},{"title":"杂项&#x2F;DiscreteMathematicNote","text":"Discrete MatheMatic Note 离散数学笔记 Author: BAIDI Date: from 2020-2-19 1 Logic and Proofs 逻辑和证明 1.1 Propositional Logic connectives 逻辑联结词 negation conjunction(合取) disjunction(析取) --inclusive/exclusive … conditional statement/biconditional statement 1.2 Applications of Propositional Logic System Specification 系统规范说明 Boolean Logic 布尔逻辑 Logic Puzzles 逻辑谜题 Logic Circuits 逻辑电路 1.3 Propositional Equivalences tautology, contradiction, contingency logically equivalent ≡ ⇔ Law De Morgan’s Law ¬(p ∧ q) ≡ ¬p ∨ ¬q ¬(p ∨ q) ≡ ¬p ∧ ¬q other Law(check relative table) ¬p ∨ q and p → q Distribute Law p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r) Law’s extension Law’s application Proposition’s Satisfiability and Problem’s Solution Soduka Puzzle’s solution 1.4 Predicates and Quantifiers 谓词和量词 Predicates 谓词 basic notion:Propositional function P (命题函数P) n-place / n-ary predicates (n位/元谓词) 包含多个变量的谓词 P(x1, x2…xn) --谓词+变量=命题 Application–verify the correctness of a programme: Precondition(input) &amp; Postcondition(output expected) (前置条件 &amp; 后置条件） Quantifiers 量词 Notions: Quantification 量化 Universal quantifier 全称量词 domain: domain of discourse 论域(universe of discouse 全体域) counterexample 反例 Existential quantifier 存在量词 Precedence 优先级 Resticted Domains 约束域 (约束域和条件，合取的等价关系) bound (被赋值或被量词联结）-绑定 scope -作用域 free -自由(未绑定的变量) Logic Equivalences Involving Quantifiers Notions: comma 逗号 Prolog --programming in logic Prolog fact / Prolog rule semicolon 分号 Nested Quantifiers 嵌套变量 Rules of inference 推理规则 argument 论证 valid 有效性 premise 前提 fallacy 谬误 argument form 推理形式 modus ponens 假言推理 （law of detachment 分离规则） hypothesis 假设 syllogism 三段论 contrapositive 逆否命题 instantiation 实例 arbitrary 任意的 Itroduction to Proofs theorem 定理 axiom 公理 lemmma 引理 corollary 推论 conjecture 猜想 vacuous proof 空证明 trivial proof 平凡证明","link":"/posts/b8e16674/"},{"title":"杂项&#x2F;Ideas","text":"Williams’s Fantastic Ideas Github 有一个叫做 app ideas 的仓库有很多好的项目 根据图片定位到视频中的某一帧","link":"/posts/853a41fd/"},{"title":"算法&#x2F;算法启蒙","text":"写在前面：“学好程序与算法，走遍天下都不怕。” 枚举 背景 找不到合适的数学公式和技巧 （改良后）枚举复杂度不是特别大 通常用于找到一种情况使之满足题意的题目 配合假设法找到目标情形：假币问题 技巧 跳跃枚举法：跳过对没有必要的情况的枚举 局部枚举法：枚举局部，剩下的由该局部确定。例如熄灯问题 递归 作用 替代多重循环，如：n皇后问题。 这种类型往往要运用到一个全局/静态变量来存储前面算过的结果，譬如n皇后就用到了一个全局数组来保存每一行的皇后拜访情况。全局/静态变量的好处就在于所有递归函数共享成果，就像递推迭代一样，每一步会影响下一步。 递归函数形式：T function( T f(n) )，函数意义：在前n-1步已经完成的情况下决定如何走第n步，往往第一个被调用的function参数为0或1（然后依次调用 $1$ ~ $n_0$） 解决实质是递归形式的问题 有些问题本身就是递归定义的，比如不少表达式就是递归定义的：逆波兰，四则运算。逆波兰直接递归调用自身定义，四则运算则包含项，因子和表达式自身等多个概念，是一种间接递归调用自身定义 函数，数列的递推公式 关键是搞清楚问题是怎样递归定义的，可以借助画图，写代数式的办法捋清楚。 将问题分解为规模更小的子问题来求解 如何来分解？ “n=1+(n-1)”法 比方说要解决一个规模为n的问题，先找到解决该问题的第一步怎么做，然后再把剩下的问题解决，剩下的问题规模刚好是n-1且解决过程自相似，可以用上递归n-1。e.g.台阶问题 “n=(n-1)+1”法 先解决n-1问题，再将最后一步完善,e.g.汉诺塔问题 与多重循环不同，该方法第一个调用的function参数往往时n0总规模 与分治不同，分治往往偏向于均分，而且多了一步综合，不过分治与递归又可以相互补充 附注 atof（）函数，将浮点串转变为浮点数 cin.peek（）函数，提前预知输入而非读取 浮点数的比较引入eps 二分 简介 对一个待求系统（通常为有序系统），每次都均分为两半，通过判断“砍掉”其中“无用”的一半，对剩下的一半用同样的方法处理，直到得出结论。 作用 二分查找 不仅限于查找某一个具体的数，还可以查找符合某种要求的数（通常满足一定的大小关系） 二分法求方程根 分治 基本思想 将一个问题拆分成两个或两个以上规模更小的问题，然后将小问题分别解决或只解决部分问题，最后综合处理一次。 一般模式：分划，局部处理，综合处理（分治 | 归并） 常常与递归思想结合 作用：使规模缩小，提高算法效率（想想：不断地递归并分治，使得规模不断二分） 应用举例：基于分治策略的快速排序和归并排序 附注 &quot; x &amp; 1 &quot; 表达式判别x奇偶性 快速幂算法 动态规划 背景 问题具有最优子结构 问题的最优解所包含的子问题的解也是最优的 问题具有无后效性 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取何种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 单纯的递归会导致大量子问题 重复计算 时 思路方法 原问题分解为子问题 一些问题的求解归结于它的子问题的求解，且子问题与原问题类似，只是规模减小。 子问题一旦解决即被保存（通常存入一个多维数组）。 确定状态 “状态”简介：在用动态规划解题时，我们往往将和子问题相 关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。 状态空间与时间复杂度：整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。（在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。） 用动态规划解题，经常碰到的情况是，K个整型变量能 构成一个状态（如数字三角形中的行号和列号这两个变量 构成“状态”）。如果这K个整型变量的取值范围分别是 N1, N2, ……Nk，那么，我们就可以用一个K维的数组 array[N1] [N2]……[Nk]来存储各个状态的“值”。这个 “值”未必就是一个整数或浮点数，可能是需要一个结构 才能表示的，那么array就可以是一个结构数组。一个 “状态”下的“值”通常会是一个或多个子问题的解。 确定一些初始状态（边界状态）的值 确定状态转移方程 将第一步 分解 得到的原问题与子问题的关系用数学符号语言表述出来，即实现状态之间的转移关系。 动规程序写法 记忆递归型 递归函数+记忆数组 “人人为我”递推型 1,2,3,…,n-1 =&gt; n 递推到“n”时“n”仍未被求出，前面已被求出的状态值用于求“n”的状态值 “我为人人”递推型 n =&gt; k (k&gt;n) 递推到“n”时“n”已经被求出，n将用于求后面的状态值 递归写法 递推写法 难度 直观简便 较复杂，可能需要结合图形理解 内存占用 较大，有爆栈风险 小，还可以用滚动数组进一步节省空间 动规中递归法向递推法转化的一般方法： 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值 是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。 常见分解（状态转移）方法归纳 多分类讨论， 想想解决原问题等同于解决什么和什么。有时候要经过多层分解才能够得到与原问题结构相同的子问题。 “n=(n-1)+1”型与&quot;n=1+(n-1)&quot;型（与 递归 的 先走一步 思想又异曲同工之妙，n为问题规模） &quot;F(i,j,k)=F(i-1,j,k)+F(i,j-1,k)+F(i,j,k-1)&quot;型（这里拿 三维 的情况举例，其他维度的状态转移方程与此大同小异） &quot;F(m,n)=A, A=G( F(m-1,n),F(m,n-1) )&quot;型，间接递归 附注 数字三角形题目启示录： ①空间优化：滚动数组（通过覆盖今后无用的旧有数据空间的方法来压缩空间），降维，关注不必要的存储空间以及运行过程中变得可以丢弃的数据。②递归化递推：逆向思维。 深度优先搜索 关键词：回溯 标记(判重) 剪枝 图 状态 简介 从某个起点开始每走一步就做一个标记，然后下一步随便选择一个没有走过的节点，走不通则回退到上一步重新选择。这种走法总是试图“走的更远”。 重要概念 图（连通图，非连通图，子图，极大连通子图…） 图上节点（或者某抽象的状态：e.g.譬如每个棋局也可以看作是一个图节点） 图上边：节点之间的联系 图路径（枝） 图的表示 邻接矩阵：L[i][j] 用一个二维数组（元素可以是一个结构，存储诸如 连通与否 路径长度 权值 方向 等内容）表示节点i与节点j之间的联系。遍历复杂度：O(n^2),n表示节点 。 邻接表：S[k] 用一个一维数组（元素可以是一个结构，存储 邻接节点 以及诸如 路径长度 权值 方向 等内容）表示所有与节点k有关的边的信息。遍历复杂度：O(n+e),n表示节点数，e表示边数。 当e特别大而接近n^2时，邻接表就失去了优势变得和邻接矩阵差不多了。 其他表示方法：具体问题具体分析。 剪枝 可行性剪枝：每搜索一个节点后发现不满足题目要求则直接回溯防止沿着这条路径继续错误地走下去。 最优性剪枝：每搜索一个节点后都对当前路径的最优性进行检验，若当前以及可以判明不是最优路径或者说接着走下去一定不是最优路径则直接回溯。 与整体最优解比较来剪枝 保存中间结果用于最优性剪枝 ：如果到达某个状态A时，发现前面曾经也到达过A，且前面那次到达A所花代价更少，则剪枝。这要求保存到达状态A的到目前为止的最少代价。 （ 对每个节点都开辟存储空间来存放以该节点为终点的当前最优解，每次搜索到一个节点就将该最优值与新值比较，原值更优则剪枝，新值更优则更新该最优值） 注意：“最优”的决定要素可能不止一项，还可能是多元因素，如：ROADS问题中有费用和路程两个因素。剪枝时要考虑控制单一变量。 广度优先搜索 简介 从节点开始层次遍历（用队列）整个图。 特点 搜到的路径一定是最短的。 占用空间较大，尤其是目标节点层次很高时。 如果题目要求路径则每次入队的元素都要包含有指向父节点的“指针”。要注意，STL中的queue容器中元素一旦出队则会导致对象的丢失，因此需要自己动手编写一个保证父节点不会丢失的队列。 一般模式 广度优先搜索算法如下：（用QUEUE） 把初始节点S0放入Open表中 如果Open表为空，则问题无解，失败退出 把Open表的第一个节点取出放入Closed表，并记该节点为n 考察节点n是否为目标节点。若是，则 得到问题的解，成功退出 若节点n不可扩展，则转第(2)步 扩展节点n，将其不在Closed表和 Open表中的子节点(判重）放入Open表的尾 部，如有必要为每一个子节点设置指向父节点的指针 (或记录节点的层次），然后转第(2)步。 DSP vs BSP 深搜 广搜 适用范围 几乎任何问题 状态表示比较简单，求最优策略的问题 优点 空间占用较少 找到的解一定路径最短 缺点 运气不好时耗时长，甚至无法在多项式时间内求解，需要剪枝优化 目标节点层次高时搜索过程将产生许多无用节点，搜索效率低且占用空间大，需要优化存储方式 结构 栈（递归） 队列 根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择 贪心 简介 只考虑当前最优，通过局部最优达到整体最优的策略 贪心算法需要证明其正确性 贪心检验：替换法 假设最优序列为{ai}，贪心得到的序列为{bi}，则只需要证明{ai}={bi}即可证明贪心得到的是整体最优。 必要时先将ai按照bi（贪心策略得到的序列）的方式排好序 然后从i=1开始逐个考虑能否将ai替换为bi而不影响ai后面序列的选择。如果对于所有i均可替换，则{ai}={bi}。 数学归纳法 附注 一类常见的应用贪心策略的题：区间题 解决思路：关注端点，合理排序，顺序处理","link":"/posts/8ee1a4a1/"},{"title":"技术&#x2F;备忘&#x2F;CMD 指令备忘","text":"CMD 指令备忘 Process 类 tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process","link":"/posts/369ceeb5/"},{"title":"技术&#x2F;备忘&#x2F;小技巧手册","text":"每天一个避坑小技巧 解决网站元素（例如图片）加载不出来的方法 浏览器下审查该元素的URL地址，然后在搜索他的域名对应的地址（https://tools.ipip.net/domain.php） 将域名解析 “xxx.xxx.xxx.xxx 域名” 加入到hosts文件中（一般在 %SystemRoot%\\system32\\drivers\\etc\\ 目录下） cmd 下 ipconfig \\flushdns 刷新试试 刷新浏览器查看效果 SSR 解决端口占用问题： 法一：在 SSR 选项设置里改变端口 法二：taskkill /pid xxx -f","link":"/posts/fac7f463/"},{"title":"技术&#x2F;备忘&#x2F;Hexo icarus 博客维护","text":"基本指令 基本指令123456789/*npm指令*/npm install/uninstall xxx//执行package.json中定义的脚本npm run server/*hexo指令*/hexo cl &amp;&amp; hexo g &amp;&amp; hexo s //清理，生成，本地服务器hexo d //部署hexagon -l //查看插件 更多 Hexo 指令 传送门 Front-matter 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） excerpt 摘要 widget icarus 主题空间 标签插件 Embed 增强了 markdown 的功能的一系列插件 info: embed 语法不要包裹在反引号中，且冒号后面不要空格！！ 官方文档 官方插件文档 其他插件 探宝方法：hexo.io 搜索 embed 自己做：&lt;embed&gt; hexo-github-card hexo-pdf hexo-tag-bilibili label - Inserts a label with text and specified color. pill - Inserts a label with text and specified color. ** text badge - Inserts a badge with text. alert - Inserts alert messages with text and specified color. card - Add a card control ** carddeck - use with cards to combine multiples ** cardgroup - similar to carddeck jumbo - jumbotron carousel - carousel tag - each img within will create a new “slide” row - add a grid row col - add a column within a grid row 使用示例 ！🐱‍🏍传送门🐱‍🏍 举亿个栗子 渲染效果因css而异 badge text alert 块级 属性：waring danger success info Best check yo self, you’re not looking too good. Change a few things up and try submitting again. You successfully read this important alert message. This alert needs your attention, but it’s not super important. textcolor （暂无css渲染） Fusce dapibus, tellus ac cursus commodo, tortor mauris nibh. Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 行内label 支持属性 default warning success danger primary info default warinng success danger primary info 行内btn 支持属性 primary success warning danger info btn btn btn btn btn btn","link":"/posts/6e7bdc/"},{"title":"技术&#x2F;工具&#x2F;IDEA 学习笔记","text":"IDEA基础功能概览： shortcut(edit, 代码片段, 功能), 版本控制(VCS: git, github, local history) Debug, javadoc generator, database, web deployment project&amp;module 等概念, 模板, 项目结构查询管理 Tips 代码段：main sout标准输出 soutv输出变量，soutm输出方法名，soutp输出命令行参数 变量名.sout输出变量 iter增强型for循环 引用名.for 迭代指定引用类型 实例名.fori顺序遍历 xxx.forr倒序遍历 ifn --“if xxx is null”, inn --“if not null” xxx.nn, xxx.ifn JavaLea 条件断点 --右键断点处 ctrl+u 查看表达式的值 Tools javadoc generator: Local: zh_CN; Other command line args: encoding UTF-8 -charset UTF-8 IDE 常用快捷键对照表（原始来源: https://www.jianshu.com/p/6267a7d76018 ) 操作 eclipse IDEA Visual Studio Code Sublime 编辑 Editing 格式化代码 Format Code Ctrl+Shift+F Ctrl+Shift+L Shift+Alt+F 无 删除行 Delete Line Ctrl+D Ctrl+Y Ctrl+Shift+K Ctrl+Shift+K 复制行 Copy Line Ctrl+C Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+Shift+Up/Down Ctrl+D Alt+Shift+Up/Down Ctrl+Shift+D 移动行 Move Line Alt+Up/Down Alt+Shift+Up/Down Alt+Up/Down Ctrl+Shift+Up/Down 换行 New Line Shift+Enter Shift+Enter Shift+Enter Ctrl+Enter 插入上行 Insert Line Above Ctrl+Shift+Enter Ctrl+Alt+Enter Ctrl+Shift+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+\\ Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Alt+Shift+Up/Down Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 优化导包 Optimize Imports Ctrl+Shift+O Ctrl+Alt+O 代码提示 Code Assist Alt+/ Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Alt+/比较low Ctrl+Shift+Enter 快速修复 Quick Fix Ctrl+1 Alt+Enter Quick Access Ctrl+3 Double Shift 参数信息 Parameter Info Alt+Shift+/还不如 Alt+/ Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Alt+Shift+N Ctrl+N 激活编辑器 Active Editor F12 Esc 全部小写 Ctrl+Shift+Y 全部大写 Ctrl+Shift+X 导航 Navigation 上/下一个Tab Ctrl+PgUp/PgDn Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Alt+Left/Right Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Q Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+L Ctrl+G 大纲/结构 Outline/Structure Ctrl+O Ctrl+F12 查看类层级 Type Hierarchy Ctrl+T 查看最近文件 Recent File Ctrl+E Ctrl+F6 Ctrl+E 跳到文件 Go To File Ctrl+Shift+N 切换视图 Switch View Ctrl+F7 重构 Refator 重命名 Rename Alt+Shift+R Shift+F6 提取变量 Extract Variable Alt+Shift+L 提取方法 Extract Method Alt+Shift+M 搜索 Find 查找下一个 Ctrl+K 查找上一个 Ctrl+Shfit+K 全局搜索 Ctrl+H","link":"/posts/5a1e79ff/"},{"title":"技术&#x2F;备忘&#x2F;IDE&amp;Editor Shortcuts Query","text":"各大 IDE &amp; Editor 快捷键对照表 操作 IntelliJ IDEA Visual Studio Code Visual Studio 编辑 Editing 格式化代码 Format Code Ctrl+Shift+L Shift+Alt+F 删除行 Delete Line Ctrl+Y Ctrl+Shift+K 选中行 Select Line Ctrl+L 复制行 Copy Line Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+D Alt+Shift+Up/Down 移动行 Move Line Alt+Shift+Up/Down Alt+Up/Down 换行 New Line Shift+Enter Shift+Enter 插入上行 Insert Line Above Ctrl+Alt+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 选择相同内容 Alt+J Ctrl+D 优化导包 Optimize Imports Ctrl+Alt+O 代码提示 Code Assist Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Shift+Enter 快速修复 Quick Fix Alt+Enter Quick Access Double Shift 参数信息 Parameter Info Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Ctrl+N 激活编辑器 Active Editor Esc 全部小写 全部大写 导航 Navigation 上/下一个Tab Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+G Ctrl+G 大纲/结构 Outline/Structure Ctrl+F12 查看类层级 Type Hierarchy 查看最近文件 Recent File Ctrl+E 跳到文件 Go To File 切换视图 Switch View 重构 Refator 重命名 Rename Shift+F6 提取变量 Extract Variable 提取方法 Extract Method 搜索 Find 查找 Find Ctrl+F Ctrl+L Ctrl+F 查找下一个 查找上一个 全局搜索","link":"/posts/fde8aecf/"},{"title":"技术&#x2F;语言&#x2F;C指针扫盲","text":"首先看看函数指针，函数名，以及它们分别与*和&amp;结合后的值 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); //puts(\"\\n接着我们尝试用上述变量调用函数:\"); //func(); //(*func)(); //(&amp;func)(); //(p_func)(); //(*p_func)(); return 0;} 执行结果 1234567func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC **可见==func==,==func==,==&amp;func==,==p_func==,==p_func==代表的值都是func()函数的地址 （ &amp;p_func是指针的地址 ） 再来看看将它们分别作为函数名的结果 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} ==func==，==p_func==，==*p_func==，==*func==，==&amp;func==作函数名 源程序 12345678 puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} 编译运行结果 12345678910111213func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC接着我们尝试用上述变量调用函数:成功调用成功调用成功调用成功调用成功调用 可见==func==，==p_func==，==*p_func==，==*func==，==&amp;func==作函数名均可以实现函数调用","link":"/posts/f1e4bda1/"},{"title":"技术&#x2F;语言&#x2F;Golang 避坑手册","text":"&quot;{&quot;的位置要注意 分号无 多变量声明： //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断 vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误 12345// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 默认值 并行特性：多个返回值，并行赋值 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： a = a++ // 这是不允许的，会出现变异错误 syntax error: unexpected ++ at end of statement ! Go 的自增，自减只能作为表达式使用，而不能用于赋值语句。 for each range loop !!! 函数闭包（同一个被赋予闭包函数的函数每次调用都会将匿名函数内的局部变量记忆下来） 12345678910111213141516package mainimport \"fmt\"func main() { add_func := add(1,2) fmt.Println(add_func(1,1)) fmt.Println(add_func(0,0)) fmt.Println(add_func(2,2))} // 闭包使用方法func add(x1, x2 int) func(x3 int,x4 int)(int,int,int) { i := 0 return func(x3 int,x4 int) (int,int,int){ i++ return i,x1+x2,x3+x4 }} := cannot be used globally!!! 全局变量和局部变量都有默认值 结构体与数组的匿名 append()必须要用它的返回值（原因很简单，其参数列表用的是值传递而不是指针传递） map必须要初始化（用make（）或者声明的时候直接赋值），否则只是个nil，无法对其进行赋值！！！？？ !!!GO没有隐式类型转换！！！需要灵活使用显示类型转换！ 将一个结构体赋值给一个接口变量可以想象成该接口成为了一个指向该结构体的“指针” 通道chan类型是“值相关”的，相同chan值描述同一个通道，chan用close（）关闭，）有点像file descriptor？ 两个并发线程时间前后关系不确定，同一个程序可能有不同结果 close一个chan后还能接收，不可发送","link":"/posts/c737d2b3/"},{"title":"技术&#x2F;语言&#x2F;JavaLearning","text":"2020-4-28 content: 对象与类，基本数据类型 int a, b; 则“a=b”表达式为int类型，不会自动转化为boolean类型 Java 的匿名内部类 Java12345678910111213//定义语法new 父类构造器（实参列表) | 实现接口() //必须继承一个父类或接口{ //匿名内部类的类体部分}/** * 规范： * 匿名类的声明是由java编译器自动派生自一个类实例创建表达式。 * 匿名类永远不能是抽象的。 * 匿名类总是隐式的final。 * 匿名类总是一个内部类；并且不能是static的。 */ 注意： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 内部类的class文件命名是：主类＋$＋内部类名 匿名类的class文件命名是：主类＋$＋(1,2,3…) class 对象 获取方式：有三种获得Class对象的方式： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class （类字面常量） 每个类的运行时的类型信息就是用Class对象表示的","link":"/posts/6374ed46/"},{"title":"技术&#x2F;笔记&#x2F;第一行代码 Android（第三版）读书笔记","text":"第一行代码 Android（第三版）读书笔记 第一章 开启征程（概要） 项目结构与目录：page 17 - page 19 Log 方法与 Logcat 的完美结合 第二章 Kotlin 语法糖 同《Kotlin 学习笔记》一同食用效果最佳 《第一行》中出现的 Kotlin 特性预览表 主次构造函数 参数默认值 键值对传参 字符串内嵌表达式 init {}, constructor () {} fun xxx(str: String = “”) {…} xxx(str = “…”) “${value}” let 函数式 API Lambda 表达式 空指针检查 函数式 API obj.let {obj2 -&gt; …} {para -&gt; …}, {it.toString()} ? ?. !!. ?: map.maxby {} //Lambda表达式 容器初始化 数据类 单例类 循环遍历 listOf(), mapOf(), setOf() data object for-in, until, downTo, step, l…r, 容器遍历 分支控制 条件控制 “不变为先” 访问控制 when () {… -&gt; …}, if-else 语句/表达式 is (instanceof), else val, var, open class “public by default” 第三章 Activity！所见即所得 创建 Activity 创建和加载布局文件 layout 在 AndroidManifest.xml 中注册Activity 编写 Activity.kt 代码 （事件绑定，方法重写等） Activity 通信与切换 Intent 类 显式切换：Intent(上下文, 指定Activity 的 Class 类) 隐式切换：指定 action category，目标将会按照注册信息中的过滤条件响应 intent。 过滤条件：&lt;category&gt; &lt;action&gt; &lt;data&gt; 传参：.putExtra(), .getStringExtra() 启动方式：startActivity() //普通启动 startActivityForResult() //请求结果 Activity 类 Result 结果 设置结果：setResult() 取回结果：override onActivityResult() Bundle 类 团队合作时用伴生类“静态方法”来启动 Activity 生命周期 返回栈 思维导图 保存信息 Bundle 类型 onSaveInstanceState()，var savedInstanceState Activity 启动模式 standard 无检查，直接压栈 singleTop 检查栈顶 singleTask 解栈恢复 singleInstance 创建新栈 第四章 UI！！ 门面功夫 :-)","link":"/posts/37a431d8/"},{"title":"技术&#x2F;语言&#x2F;Java&amp;Kotlin语法对照","text":"Java &amp; Kotlin 的语法片段对照 函数式 API Java 123456789101112//传入接口类型的实例（或继承了接口的匿名类）/* public interface Runnable { void Run(); } */new Thread(new Runnable() { @Override public void run() { //执行逻辑 }}).start() Kotlin 1234//传入Lambda表达式（单抽象的接口类型也可简化为Lambda表达式后传入）Thread { //执行逻辑}.start() 访问控制 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 Class 对象引用 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class","link":"/posts/7a368ad4/"},{"title":"技术&#x2F;开发&#x2F;AndroidLearning","text":"Android Studio 入坑笔记 Android Studio 自动创建 resource id 失败 重启 AS。 Sync with file system 同步一下？ 查看 R.java 中的 id 。Project 下依次打开app–&gt;build–&gt;generated–&gt;source–&gt;r–&gt;debug，在debug中的两个选项的子文件中分别有有一个R文件，既我们要找的R.java文件。（或者直接shift+shift查找R.java","link":"/posts/fae5c3cd/"},{"title":"技术&#x2F;语言&#x2F;Kotlin","text":"Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 $a 和 ${a.func()}我是真没话说。 完善的NULL检查机制 “!!, ?, ?:”（当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。方法是： “Type后 + ？”） 玩转for循环：可以方便的指定遍历的步长，范围。（ …, step, downTo, in, until) Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符==不属于==数值类型，是一个独立的数据类型。 支持二进制字面量，数值类型混入下划线增加语义性。 有些时候较小类型不会隐式转换成较大类型，需要手动调用 .toXXX() 来进行显示的类型转换。 和 golang 一样少了分号（这就是语法糖吗i了i了 if-else 语句与when语句等可以视为 ==表达式==（可赋值 when 与 -&gt; 符号构成强大的分支控制。 完全抛弃基本数据类型改用对象数据类型“。 “fun xxx() = xxx” 这个语法糖结合 if else, when 等特性可以打出漂亮的组合拳。 class 继承的时候对继承的父类后面一般要加括号（因为 java 继承中必调用父类构造函数）且此构造函数必调用著构造函数。 Java 与 Kotlin 访问修饰符对照表 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 语法糖: 原生支持数据类、单例类 （自动完成 toString(), hashCode(), equals() 等方法） 数据类对比 Java-example12345678910111213141516171819202122232425262728public class Cellphone { String brand; double price; public Cellphone(String brand, double price) { this.brand = brand; this.price = price; } @Override public boolean equals(Object obj) { if (obj instanceof Cellphone) { Cellphone other = (Cellphone) obj; return other.brand.equals(brand) &amp;&amp; other.price == price; } return false; } @Override public int hashCode() { return brand.hashCode() + (int) price; } @Override public String toString() { return \"Cellphone(brand=\" + brand + \", price=\" + price + \")\"; }} Kotlin-example1data class Cellphone(val brand: String, val price: Double) //加一个data即可 单例类对比 Java-example12345678910111213141516public class Singleton { private static Singleton instance; private Singleton() {} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } public void singletonTest() { System.out.println(\"singletonTest is called.\"); }} Kotlin-example12345object Singleton { //只需要用object代替class即可 fun singletonTest() { println(\"singletonTest is called.\") } //这里相当于一个静态方法} Kotlin class 类 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class Kotlin 标准函数 一系列定义于 Standard.kt 里的函数 参照表 函数 特点 代码段 let() 调用let的对象作为Lamda的参数，返回最后一行 obj.let {(obj2 -&gt;) //obj2是obj} with() 传入对象作为Lambda的上下文，返回最后一行 with(obj) {//obj上下文} run() 调用run的对象作为Lamda的上下文，返回最后一行 obj.run {//obj上下文} apply() 调用apply的对象作为Lamda的上下文，返回原对象 obj.apply {//obj上下文} Kotlin “静态方法调用” 单例类 objetc {} 伴生类 companion object {} 顶层方法 fun xxx()，可以被任意Kotlin代码直接调用，文件名作为类还可以用于java静态方法调用 @JvmStatic 注释，只能加注在单例类方法或伴生类方法上，使其编译成java静态方法","link":"/posts/ec3dabc7/"},{"title":"技术&#x2F;语言&#x2F;LatexTikz","text":"Tikz 绘图学习笔记 注意事项: \\begin{tikzpicture} 环境下每一行命令结尾都要加分号; \\node, \\coordinate, \\draw 语法参考：https://zhuanlan.zhihu.com/p/84943429 \\node 描点, \\coordinate 拟点, \\draw 画线, \\fill 填充 参考网站: 路径与坐标：https://www.latexstudio.net/archives/51602.html node 控制：https://www.latexstudio.net/archives/51617.html 线条控制: https://www.latexstudio.net/archives/51622.html 示例代码: 12\\node at (A)[circle,fill,inner sep=1pt]{};% 点名 属性","link":"/posts/9b17222d/"}],"tags":[{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"搜索算法","slug":"搜索算法","link":"/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"工具","slug":"技术/工具","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"},{"name":"备忘","slug":"技术/备忘","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%A4%87%E5%BF%98/"},{"name":"语言","slug":"技术/语言","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"},{"name":"笔记","slug":"技术/笔记","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"},{"name":"开发","slug":"技术/开发","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"}]}