{"pages":[{"title":"About","text":"","link":"/about/"},{"title":"books","text":"","link":"/books/"},{"title":"Repositories","text":"","link":"/repository/"},{"title":"share","text":"","link":"/share/"},{"title":"Gallery 画廊","text":"🎮 机械猎人 《Horizon: Zero Dawn》游戏剪影 原始世界里活跃的”机械生命体“，古奥森然的前人类文明遗迹，冷兵器碰撞上机甲护板摩擦出的层层火花，Zero Dawn 这款游戏带给了我太多太多的视觉享受和战斗趣味。没落的世界碰撞上遗留的机械体，造就出一座幻想殿堂，让人不由自主地穿梭其中，流连忘返。 🖊米山舞のペン 画师：米山舞 关键词：少女与潮服","link":"/gallery/"},{"title":"Category","text":"","link":"/categories/"},{"title":"Tag","text":"","link":"/tags/"}],"posts":[{"title":"Hexo&#39;s tag","text":"Hexo 的插件扩展调试页面 classDiagram class NotificationManager { +notify() +createNotificationChannel() } class NotificationChannel class NotificationCompat { +Builder() } NotificationCompat NotificationChannel: 创建、管理 NotificationManager --> Notification: 发送 Notification --* NotificationChannel: 对应","link":"/posts/827933de/"},{"title":"算法&#x2F;序列标注之HMM与CRF模型","text":"机器学习 HMM CRF 绪论 ​ 从文本翻译到文字、语音识别，再到命名实体识别，词性标注，序列标注问题已然渗透到社会生活中的方方面面。不少自然语言处理的问题都可以想方设法转化为序列标注问题：对邮件等”大块“的信息做命名实体识别，识别出信息中的表单项用于自动填写表单，可以有效地提高工作效率，节约时间；对音频文件进行标注分析，可以用来进行语音识别；抽取出来的电子病历文本中的疾病、治疗、检查等类型的实体，可以用以对电子病历进行分类归档…想要处理好一般性的自然语言处理问题到序列标记问题的转化，关键在于处理好如何定义标记的问题。 ​ 作为自然语言处理中常见的问题之一，序列标注问题已经由来已久，并在经历了一系列的发展变革后逐渐壮大健全。最早的有传统的隐马尔可夫模型、最大熵模型和条件随机场模型，最大熵模型抛弃了隐马尔科夫模型的独立输出假设，而条件随机场模型又在最大熵模型的基础上进一步将标签的转移扩大为全局特征，使得上下文之间的联系更加紧密。无论是在理论还是实践结果上来看，条件随机场的整体效果都要优于前两种方法。步入深度学习发展的时代后，新的诸如RNNRNNRNN和LSTMLSTMLSTM模型也相继用于序列标注问题，有效地改善了传统方法在处理更长的上下文依赖、过拟合、依赖启发式知识等方面的不足之处。本文主要研究和探讨了传统的序列标注模型——隐马尔可夫模型和条件随机场模型——的理论基础和应用实践。 正文 定义 ​ 序列标注是指将输入的一串观测序列 x1x2x3...xnx_1x_2x_3...x_nx1​x2​x3​...xn​ 转化为一串标记序列 y1y2y3...yny_1y_2y_3...y_ny1​y2​y3​...yn​ 的过程，要解决序列标记问题，实际上就是要找到一个观测序列到标记序列的映射 f(xi)→yi (i=1,2,...,n)f(x_i)\\rightarrow y_i\\space (i=1,2,...,n)f(xi​)→yi​ (i=1,2,...,n)。 HMM模型 马尔可夫链 马尔可夫链（Markov chain）1，又称离散时间马尔可夫链，为状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。 ​ 从数学形式上来看，对于随机变量序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−1=xn−1)P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})=P(X_n=x_n|X_{n-1}=x_{n-1}) P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)=P(Xn​=xn​∣Xn−1​=xn−1​) ，则称该序列为一个一阶马尔可夫链。 ​ 从宏观意义上来看，Markov链说明了在状态转移过程中，“未来”与“过去”无关而只与“现在”有关。 ​ Markov链常常被认为是时齐的，即转移概率与n无关。 ​ 类似的可以定义m阶Markov链，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−m=xn−m,Xn−m+1=xn−m+1...,Xn−1=xn−1)\\begin{aligned} &P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})\\\\ =&P(X_n=x_n|X_{n-m}=x_{n-m},X_{n-m+1}=x_{n-m+1}...,X_{n-1}=x_{n-1}) \\end{aligned} =​P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)P(Xn​=xn​∣Xn−m​=xn−m​,Xn−m+1​=xn−m+1​...,Xn−1​=xn−1​)​ 隐马尔可夫模型 ​ 隐马尔可夫模型（Hidden Markov Model 缩写：HMM）基于Markov链，不同与一般的Markov链，HMM 又加入了隐变量这一概念，即该模型包含了观测序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​和与它一一对应的标记序列Y1Y2Y3...YnY_1Y_2Y_3...Y_nY1​Y2​Y3​...Yn​。该模型用到了两个基本假设： 时齐的Markov性假设，如2.2.1所述 独立输出假设，输出状态的概率仅与输入状态相关，而与输入序列的前后文无关 以图形表示的隐马尔可夫模型如下所示： HMM 模型解决了被用来解决序列标注问题中的三个基本问题：预测、平滑和解码。本文主要讨论的解码问题，即求解给定观测序列，给出最有可能的标记序列的问题。本文使用λ(W,T,π,β,A,B)\\lambda(W,T,\\pi,\\beta,A,B)λ(W,T,π,β,A,B)来表征一个序列标注问题的HMM模型，其中WWW表示观测序列，TTT表示输出的标记序列，π\\piπ表示标记之间的概率转移转移矩阵，β\\betaβ表示标记到观测值的发射概率，AAA表示输入对象的集合，BBB表示标记的集合。 概率模型 问题归结于求解下式 argTmax P(T=t1t2...tn∣W=w1w2...wn,λ)(ti∈B,wi∈A)(1)arg_{T}max\\space P(T=t_1t_2...t_n|W=w_1w_2...w_n,\\lambda)\\qquad (t_i\\in B, w_i\\in A)\\tag{1} argT​max P(T=t1​t2​...tn​∣W=w1​w2​...wn​,λ)(ti​∈B,wi​∈A)(1) 由贝叶斯概率公式 P(T∣W)=P(W∣T)P(T)P(W)∝P(W∣T)P(T)(2)P(T|W)=\\frac{P(W|T)P(T)}{P(W)}\\propto P(W|T)P(T)\\tag{2} P(T∣W)=P(W)P(W∣T)P(T)​∝P(W∣T)P(T)(2) 因为 P(W)=constP(W)=constP(W)=const 故而可以省略不予以考虑 由独立输出假设可知 P(W∣T)=P(w1∣t1)P(w2∣t2)...P(wn∣tn)(3)P(W|T)=P(w_1|t_1)P(w_2|t_2)...P(w_n|t_n)\\tag{3} P(W∣T)=P(w1​∣t1​)P(w2​∣t2​)...P(wn​∣tn​)(3) 由一阶时齐的Markov性假设可知 P(T)=P(t1)P(t2∣t1)P(t3∣t2)...P(tn∣tn−1)(4)P(T)=P(t_1)P(t_2|t_1)P(t_3|t_2)...P(t_{n}|t_{n-1})\\tag{4} P(T)=P(t1​)P(t2​∣t1​)P(t3​∣t2​)...P(tn​∣tn−1​)(4) 联立方程 (2)(3)(4)⇒(2)(3)(4)\\Rightarrow(2)(3)(4)⇒ P(T∣W)∼[P(t1)P(w1∣t1)][P(t2∣t1)P(w2∣t2)]...[P(tn∣tn−1)P(wn∣tn)](5)P(T|W)\\sim [P(t_1)P(w_1|t_1)][P(t_2|t_1)P(w_2|t_2)]...[P(t_n|t_n-1)P(w_n|t_n)]\\tag{5} P(T∣W)∼[P(t1​)P(w1​∣t1​)][P(t2​∣t1​)P(w2​∣t2​)]...[P(tn​∣tn​−1)P(wn​∣tn​)](5) 其中转移概率由条件概率公式可知 P(ti∣ti−1)=P(ti,ti−1)P(ti−1)(6)P(t_i|t_{i-1})=\\frac{P(t_i,t_{i-1})}{P(t_{i-1})}\\tag{6} P(ti​∣ti−1​)=P(ti−1​)P(ti​,ti−1​)​(6) 等式(6)(6)(6)中标记值的概率和等式(5)(5)(5)中的独立输出概率可由统计方法或规则方法得出，下面介绍两种方法的异同： 项目 统计方法 规则方法 介绍 通过统计得出频率估计概率的方法 通过既定的规则来估计概率的方法 优点 覆盖面广，稳定性高 精确，对于特殊现象的支持度好 缺点 对于特殊现象的支持度差 规则库庞大，编写和维护复杂，覆盖面不及统计方法 能够计算出特定T∗T^*T∗的概率值P(T∗∣W)P(T^*|W)P(T∗∣W)还不够，还要要找到最大的概率对应的TTT。这个问题可以转化成一个求解最短加权路径的图论问题。 可构建像 graph 1 所示的图模型（其余路径未画出）。显然，如果标记的取值有mmm种可能，序列的长度为nnn，那么枚举所有路径然后取加权值最大的路径的算法复杂度为 O(nm)O(n^m)O(nm) ，随着序列长度增长而呈指数级增长。为了降低复杂度这里一般采用维特比算法 (Viterbi algorithm) 。 The Viterbi algorithm2 is a dynamic programming algorithm for finding the most likely sequence of hidden states—called the Viterbi path—that results in a sequence of observed events, especially in the context of Markov information sources and hidden Markov models (HMM). 维特比算法是一种动态规划算法，用于找出隐藏的最大可能路径（维特比路径）。维特比算法的核心思想在于全局最优包含局部最优。考虑从起点到某个中间点的最大加权路径，那么该路径所经过的该中间点的前一个点在同时间上所有点中也一定是加权最大的点。下面给出了Viterbi算法的伪代码。其中T1,T2T_1,T_2T1​,T2​分别为保存当前节点最大累计权值的矩阵和保存该节点最大累计权值路径上的上一个节点的矩阵。以下给出了维特比算法的算法伪代码： 下溢问题：(5)(5)(5) 式中的连乘积中因子有可能过小而下溢为零从而造成整个式子变为0，为了避免这种情况可以考虑取对数化乘积为加法的技巧。 应用 ​ 绝大多数自然语言处理问题（Natural Language Processing Problem，简称NLP问题），都可以转化为一个序列标注问题。想要处理好NLP问题到序列标记问题的转化关键在于处理好如何定义标记的问题。例如对于中文分词问题，可以定义标签集合 T={B,M,E,S}T=\\{B,M,E,S\\}T={B,M,E,S} ，其中 B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single) 分别表示词的开头，中间，结尾和单个字成词；对于词性标注问题，可以在分词处理的基础上让一个词对应一个词性标签。对于命名实体识别问题，可以定义标签集合 T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N}T=\\{BL,ML,EL,BP,MP,EP,BO,MO,EO,N\\}T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N} 其中 B,M,EB,M,EB,M,E 后面跟着的 L(location),P(person),O(organization)L(location),P(person),O(organization)L(location),P(person),O(organization) 分别表示地名，人民，机构名，而 NNN 表示不属于实体的部分。定义好标记之后输入训练好的模型后问题即可求解。 CRF 模型 随机场、马尔可夫随机场、条件随机场 ​ 考虑一个空间内各个区域按照某种分布被赋予了某个随机值，这样的场称之为“随机场”。而马尔可夫随机场则是一类特殊的随机场，场中每个点的赋值不仅与自身位置有关，还和相邻位置的赋值相关。如果考虑马尔科夫性的同时将点的赋值概率看做是条件概率，则称该马尔科夫场为条件随机场（Conditional random fields 简称：CRF）。如维基百科3中所述: Whereas a classifier predicts a label for a single sample without considering “neighboring” samples, a CRF can take context into account. ​ CRF模型和那些仅仅只考虑自身来进行分类的模型不同之处就在于CRF模型将样本点的“邻居”也考虑在内，这个特点使得CRF模型有能力处理上下文有关联的序列标注的问题。 线性链条件随机场 线性链的条件随机场（Linear conditional random fields）是对条件随机场的简化模型：X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn) 均为线性链表示的随机变量序列，在给定随机变量序列XXX的情况下，随机变量YYY的条件概率分布 P(Y∣X)P(Y|X)P(Y∣X) 构成条件随机场，即满足马尔科夫性： P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7)P(Yi|X,Y1,Y2,...Yn)=P(Yi|X,Yi−1,Yi+1)\\tag{7} P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7) 则称 P(Y∣X)P(Y|X)P(Y∣X) 为线性链条件随机场。 概率模型 ​ 为了建立可供学习的CRF模型，可以定义两类特征函数（这些特征函数用来评价一个序列在某些特征方面是否“靠谱”，只有 1,01, 01,0 两种取值，即判断是否满足条件）：一类只与当前节点有关，表示为sl(yi,x,i) (l=1,2...,m)s_l(y_i,x,i)\\space (l=1,2...,m)sl​(yi​,x,i) (l=1,2...,m)；另一类还与前一个节点有关，表示为tk(yi−1,yi,x,i) (k=1,2...,n)t_k(y_{i-1},y_i,x,i)\\space (k=1,2...,n)tk​(yi−1​,yi​,x,i) (k=1,2...,n)。引入需要学习的权重参数（所谓“权重”即用来衡量一个判断依据的重要程度的参数）λl,μk\\lambda_l,\\mu_kλl​,μk​，则条件概率表示为 P(y∣x)=1Z(x)exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))∝exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(8)\\begin{aligned} P(y|x)&=\\frac{1}{Z(x)}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\\\ &\\propto exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i)) \\end{aligned}\\tag{8} P(y∣x)​=Z(x)1​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))∝exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))​(8) Z(x)Z(x)Z(x)为规范化因子，是所有可能的标注序列的概率和，使得等式右边规范为一个概率。 Z(x)=∑yexp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(9)Z(x)=\\sum_{y}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\tag{9} Z(x)=y∑​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))(9) 为了使得表示更加方便，将参数 λ,μ\\lambda,\\muλ,μ 均表示为 www ，特征函数 t,st, st,s 均表示为 fff ，即有 wk={λk(0","link":"/posts/568ec988/"},{"title":"算法&#x2F;回合制战斗","text":"一小道C语言题带来的乐趣 要用游戏的玩法打败游戏的情景题! 对于以下题目： 某游戏规则中，甲乙双方每个回合的战斗总是有一方胜利，一方失败。游戏规定：失败的一方要把自己的体力值的1/4加给胜利的一方。例如：如果双方体力值当前都是4，则经过一轮战斗后，双方的体力值会变为：5，3。现在已知：双方开始时的体力值甲：1000，乙：2000。假设战斗中，甲乙获胜的概率都是50%，求解：双方经过4个回合的战斗，体力值之差小于1000的理论概率。 用基础模拟算法来解决： 1234567891011121314151617181920212223242526272829303132333435363738394041#include#define all 16//所有可能的结果数目int exchange(double * x,double * y) //x为吸收血量方 { double t; t=(*y)*0.25;(*x)+=t;(*y)-=t; return 0; } int main(){ int js=0; double x=1000,y=2000; //美好的游戏模拟开始了 for(int i=0;i","link":"/posts/aee17ffb/"},{"title":"算法&#x2F;算法启蒙","text":"算法 写在前面：“学好程序与算法，走遍天下都不怕。” 枚举 背景 找不到合适的数学公式和技巧 （改良后）枚举复杂度不是特别大 通常用于找到一种情况使之满足题意的题目 配合假设法找到目标情形：假币问题 技巧 跳跃枚举法：跳过对没有必要的情况的枚举 局部枚举法：枚举局部，剩下的由该局部确定。例如熄灯问题 递归 作用 替代多重循环，如：n皇后问题。 这种类型往往要运用到一个全局/静态变量来存储前面算过的结果，譬如n皇后就用到了一个全局数组来保存每一行的皇后拜访情况。全局/静态变量的好处就在于所有递归函数共享成果，就像递推迭代一样，每一步会影响下一步。 递归函数形式：T function( T f(n) )，函数意义：在前n-1步已经完成的情况下决定如何走第n步，往往第一个被调用的function参数为0或1（然后依次调用 111 ~ n0n_0n0​） 解决实质是递归形式的问题 有些问题本身就是递归定义的，比如不少表达式就是递归定义的：逆波兰，四则运算。逆波兰直接递归调用自身定义，四则运算则包含项，因子和表达式自身等多个概念，是一种间接递归调用自身定义 函数，数列的递推公式 关键是搞清楚问题是怎样递归定义的，可以借助画图，写代数式的办法捋清楚。 将问题分解为规模更小的子问题来求解 如何来分解？ “n=1+(n-1)”法 比方说要解决一个规模为n的问题，先找到解决该问题的第一步怎么做，然后再把剩下的问题解决，剩下的问题规模刚好是n-1且解决过程自相似，可以用上递归n-1。e.g.台阶问题 “n=(n-1)+1”法 先解决n-1问题，再将最后一步完善,e.g.汉诺塔问题 与多重循环不同，该方法第一个调用的function参数往往时n0总规模 与分治不同，分治往往偏向于均分，而且多了一步综合，不过分治与递归又可以相互补充 附注 atof（）函数，将浮点串转变为浮点数 cin.peek（）函数，提前预知输入而非读取 浮点数的比较引入eps 二分 简介 对一个待求系统（通常为有序系统），每次都均分为两半，通过判断“砍掉”其中“无用”的一半，对剩下的一半用同样的方法处理，直到得出结论。 作用 二分查找 不仅限于查找某一个具体的数，还可以查找符合某种要求的数（通常满足一定的大小关系） 二分法求方程根 分治 基本思想 将一个问题拆分成两个或两个以上规模更小的问题，然后将小问题分别解决或只解决部分问题，最后综合处理一次。 一般模式：分划，局部处理，综合处理（分治 | 归并） 常常与递归思想结合 作用：使规模缩小，提高算法效率（想想：不断地递归并分治，使得规模不断二分） 应用举例：基于分治策略的快速排序和归并排序 附注 \" x & 1 \" 表达式判别x奇偶性 快速幂算法 动态规划 背景 问题具有最优子结构 问题的最优解所包含的子问题的解也是最优的 问题具有无后效性 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取何种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 单纯的递归会导致大量子问题 重复计算 时 思路方法 原问题分解为子问题 一些问题的求解归结于它的子问题的求解，且子问题与原问题类似，只是规模减小。 子问题一旦解决即被保存（通常存入一个多维数组）。 确定状态 “状态”简介：在用动态规划解题时，我们往往将和子问题相 关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。 状态空间与时间复杂度：整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。（在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。） 用动态规划解题，经常碰到的情况是，K个整型变量能 构成一个状态（如数字三角形中的行号和列号这两个变量 构成“状态”）。如果这K个整型变量的取值范围分别是 N1, N2, ……Nk，那么，我们就可以用一个K维的数组 array[N1] [N2]……[Nk]来存储各个状态的“值”。这个 “值”未必就是一个整数或浮点数，可能是需要一个结构 才能表示的，那么array就可以是一个结构数组。一个 “状态”下的“值”通常会是一个或多个子问题的解。 确定一些初始状态（边界状态）的值 确定状态转移方程 将第一步 分解 得到的原问题与子问题的关系用数学符号语言表述出来，即实现状态之间的转移关系。 动规程序写法 记忆递归型 递归函数+记忆数组 “人人为我”递推型 1,2,3,…,n-1 => n 递推到“n”时“n”仍未被求出，前面已被求出的状态值用于求“n”的状态值 “我为人人”递推型 n => k (k>n) 递推到“n”时“n”已经被求出，n将用于求后面的状态值 递归写法 递推写法 难度 直观简便 较复杂，可能需要结合图形理解 内存占用 较大，有爆栈风险 小，还可以用滚动数组进一步节省空间 动规中递归法向递推法转化的一般方法： 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值 是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。 常见分解（状态转移）方法归纳 多分类讨论， 想想解决原问题等同于解决什么和什么。有时候要经过多层分解才能够得到与原问题结构相同的子问题。 “n=(n-1)+1”型与\"n=1+(n-1)\"型（与 递归 的 先走一步 思想又异曲同工之妙，n为问题规模） \"F(i,j,k)=F(i-1,j,k)+F(i,j-1,k)+F(i,j,k-1)\"型（这里拿 三维 的情况举例，其他维度的状态转移方程与此大同小异） \"F(m,n)=A, A=G( F(m-1,n),F(m,n-1) )\"型，间接递归 附注 数字三角形题目启示录： ①空间优化：滚动数组（通过覆盖今后无用的旧有数据空间的方法来压缩空间），降维，关注不必要的存储空间以及运行过程中变得可以丢弃的数据。②递归化递推：逆向思维。 深度优先搜索 关键词：回溯 标记(判重) 剪枝 图 状态 简介 从某个起点开始每走一步就做一个标记，然后下一步随便选择一个没有走过的节点，走不通则回退到上一步重新选择。这种走法总是试图“走的更远”。 重要概念 图（连通图，非连通图，子图，极大连通子图…） 图上节点（或者某抽象的状态：e.g.譬如每个棋局也可以看作是一个图节点） 图上边：节点之间的联系 图路径（枝） 图的表示 邻接矩阵：L[i][j] 用一个二维数组（元素可以是一个结构，存储诸如 连通与否 路径长度 权值 方向 等内容）表示节点i与节点j之间的联系。遍历复杂度：O(n^2),n表示节点 。 邻接表：S[k] 用一个一维数组（元素可以是一个结构，存储 邻接节点 以及诸如 路径长度 权值 方向 等内容）表示所有与节点k有关的边的信息。遍历复杂度：O(n+e),n表示节点数，e表示边数。 当e特别大而接近n^2时，邻接表就失去了优势变得和邻接矩阵差不多了。 其他表示方法：具体问题具体分析。 剪枝 可行性剪枝：每搜索一个节点后发现不满足题目要求则直接回溯防止沿着这条路径继续错误地走下去。 最优性剪枝：每搜索一个节点后都对当前路径的最优性进行检验，若当前以及可以判明不是最优路径或者说接着走下去一定不是最优路径则直接回溯。 与整体最优解比较来剪枝 保存中间结果用于最优性剪枝 ：如果到达某个状态A时，发现前面曾经也到达过A，且前面那次到达A所花代价更少，则剪枝。这要求保存到达状态A的到目前为止的最少代价。 （ 对每个节点都开辟存储空间来存放以该节点为终点的当前最优解，每次搜索到一个节点就将该最优值与新值比较，原值更优则剪枝，新值更优则更新该最优值） 注意：“最优”的决定要素可能不止一项，还可能是多元因素，如：ROADS问题中有费用和路程两个因素。剪枝时要考虑控制单一变量。 广度优先搜索 简介 从节点开始层次遍历（用队列）整个图。 特点 搜到的路径一定是最短的。 占用空间较大，尤其是目标节点层次很高时。 如果题目要求路径则每次入队的元素都要包含有指向父节点的“指针”。要注意，STL中的queue容器中元素一旦出队则会导致对象的丢失，因此需要自己动手编写一个保证父节点不会丢失的队列。 一般模式 广度优先搜索算法如下：（用QUEUE） 把初始节点S0放入Open表中 如果Open表为空，则问题无解，失败退出 把Open表的第一个节点取出放入Closed表，并记该节点为n 考察节点n是否为目标节点。若是，则 得到问题的解，成功退出 若节点n不可扩展，则转第(2)步 扩展节点n，将其不在Closed表和 Open表中的子节点(判重）放入Open表的尾 部，如有必要为每一个子节点设置指向父节点的指针 (或记录节点的层次），然后转第(2)步。 DSP vs BSP 深搜 广搜 适用范围 几乎任何问题 状态表示比较简单，求最优策略的问题 优点 空间占用较少 找到的解一定路径最短 缺点 运气不好时耗时长，甚至无法在多项式时间内求解，需要剪枝优化 目标节点层次高时搜索过程将产生许多无用节点，搜索效率低且占用空间大，需要优化存储方式 结构 栈（递归） 队列 根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择 贪心 简介 只考虑当前最优，通过局部最优达到整体最优的策略 贪心算法需要证明其正确性 贪心检验：替换法 假设最优序列为{ai}，贪心得到的序列为{bi}，则只需要证明{ai}={bi}即可证明贪心得到的是整体最优。 必要时先将ai按照bi（贪心策略得到的序列）的方式排好序 然后从i=1开始逐个考虑能否将ai替换为bi而不影响ai后面序列的选择。如果对于所有i均可替换，则{ai}={bi}。 数学归纳法 附注 一类常见的应用贪心策略的题：区间题 解决思路：关注端点，合理排序，顺序处理","link":"/posts/8ee1a4a1/"},{"title":"杂项&#x2F;DiscreteMathematicNote","text":"Discrete MatheMatic Note 离散数学笔记 Author: BAIDI Date: from 2020-2-19 1 Logic and Proofs 逻辑和证明 1.1 Propositional Logic connectives 逻辑联结词 negation conjunction(合取) disjunction(析取) --inclusive/exclusive … conditional statement/biconditional statement 1.2 Applications of Propositional Logic System Specification 系统规范说明 Boolean Logic 布尔逻辑 Logic Puzzles 逻辑谜题 Logic Circuits 逻辑电路 1.3 Propositional Equivalences tautology, contradiction, contingency logically equivalent ≡ ⇔ Law De Morgan’s Law ¬(p ∧ q) ≡ ¬p ∨ ¬q ¬(p ∨ q) ≡ ¬p ∧ ¬q other Law(check relative table) ¬p ∨ q and p → q Distribute Law p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r) Law’s extension Law’s application Proposition’s Satisfiability and Problem’s Solution Soduka Puzzle’s solution 1.4 Predicates and Quantifiers 谓词和量词 Predicates 谓词 basic notion:Propositional function P (命题函数P) n-place / n-ary predicates (n位/元谓词) 包含多个变量的谓词 P(x1, x2…xn) --谓词+变量=命题 Application–verify the correctness of a programme: Precondition(input) & Postcondition(output expected) (前置条件 & 后置条件） Quantifiers 量词 Notions: Quantification 量化 Universal quantifier 全称量词 domain: domain of discourse 论域(universe of discouse 全体域) counterexample 反例 Existential quantifier 存在量词 Precedence 优先级 Resticted Domains 约束域 (约束域和条件，合取的等价关系) bound (被赋值或被量词联结）-绑定 scope -作用域 free -自由(未绑定的变量) Logic Equivalences Involving Quantifiers Notions: comma 逗号 Prolog --programming in logic Prolog fact / Prolog rule semicolon 分号 Nested Quantifiers 嵌套变量 Rules of inference 推理规则 argument 论证 valid 有效性 premise 前提 fallacy 谬误 argument form 推理形式 modus ponens 假言推理 （law of detachment 分离规则） hypothesis 假设 syllogism 三段论 contrapositive 逆否命题 instantiation 实例 arbitrary 任意的 Itroduction to Proofs theorem 定理 axiom 公理 lemmma 引理 corollary 推论 conjecture 猜想 vacuous proof 空证明 trivial proof 平凡证明","link":"/posts/b8e16674/"},{"title":"杂项&#x2F;Ideas","text":"Williams’s Fantastic Ideas Github 有一个叫做 app ideas 的仓库有很多好的项目 根据图片定位到视频中的某一帧","link":"/posts/853a41fd/"},{"title":"杂项&#x2F;读书笔记约法三章","text":"读书笔记约法三章 “无他，唯手熟尔” 读书不做笔记，不常常温习约等于没学，重视笔记，舍得投入时间。 一曰： 读完一章后提炼出主要知识点，并结合 自己的理解 进行记录。 二曰： 读的过程中发现每一章节的联系（理解作者这样编排内容的深意），及时对之前的笔记进行补充说明甚至重新理解。 三曰： 进行二次阅读甚至多次阅读，修改理解不到位的、遗漏的知识点。 四曰： 实际运用书中内容的时候将遇到的问题、积累的经验写在笔记中。","link":"/posts/e8be4afa/"},{"title":"技术&#x2F;开发&#x2F;AndroidLearning","text":"Android Studio 入坑笔记 Android Studio 自动创建 resource id 失败 重启 AS。 Sync with file system 同步一下？ 查看 R.java 中的 id 。Project 下依次打开app–>build–>generated–>source–>r–>debug，在debug中的两个选项的子文件中分别有有一个R文件，既我们要找的R.java文件。（或者直接shift+shift查找R.java","link":"/posts/fae5c3cd/"},{"title":"技术&#x2F;指南&#x2F;CMD 指令备忘","text":"CMD 指令备忘 Process 类 tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process","link":"/posts/369ceeb5/"},{"title":"技术&#x2F;语言&#x2F;C指针扫盲","text":"首先看看函数指针，函数名，以及它们分别与*和&结合后的值 程序清单 12345678910111213141516171819#includevoid func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&p_func=%p\",func,*func,&func,p_func,\\ *p_func,&p_func); //puts(\"\\n接着我们尝试用上述变量调用函数:\"); //func(); //(*func)(); //(&func)(); //(p_func)(); //(*p_func)(); return 0;} 执行结果 1234567func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&func=004015C0p_func=004015C0*p_func=004015C0&p_func=0061FECC 可见func,*func,&func,p_func,*p_func代表的值都是func()函数的地址 （ &p_func是指针的地址 ） 再来看看将它们分别作为函数名的结果 程序清单 12345678910111213141516171819#includevoid func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&p_func=%p\",func,*func,&func,p_func,\\ *p_func,&p_func); puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&func)(); (p_func)(); (*p_func)(); return 0;} func，p_func，*p_func，*func，&func作函数名 源程序 12345678 puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&func)(); (p_func)(); (*p_func)(); return 0;} 编译运行结果 12345678910111213func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&func=004015C0p_func=004015C0*p_func=004015C0&p_func=0061FECC接着我们尝试用上述变量调用函数:成功调用成功调用成功调用成功调用成功调用 可见func，p_func，*p_func，*func，&func作函数名均可以实现函数调用","link":"/posts/f1e4bda1/"},{"title":"技术&#x2F;指南&#x2F;IDE&amp;Editor Shortcuts Query","text":"各大 IDE & Editor 快捷键对照表 操作 IntelliJ IDEA Visual Studio Code Visual Studio 编辑 Editing 格式化代码 Format Code Ctrl+Shift+L Shift+Alt+F 删除行 Delete Line Ctrl+Y Ctrl+Shift+K 选中行 Select Line Ctrl+L 复制行 Copy Line Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+D Alt+Shift+Up/Down 移动行 Move Line Alt+Shift+Up/Down Alt+Up/Down 换行 New Line Shift+Enter Shift+Enter 插入上行 Insert Line Above Ctrl+Alt+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 选择相同内容 Alt+J Ctrl+D 优化导包 Optimize Imports Ctrl+Alt+O 代码提示 Code Assist Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Shift+Enter 快速修复 Quick Fix Alt+Enter Quick Access Double Shift 参数信息 Parameter Info Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Ctrl+N 激活编辑器 Active Editor Esc 全部小写 全部大写 导航 Navigation 上/下一个Tab Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+G Ctrl+G 大纲/结构 Outline/Structure Ctrl+F12 查看类层级 Type Hierarchy 查看最近文件 Recent File Ctrl+E 跳到文件 Go To File 切换视图 Switch View 重构 Refator 重命名 Rename Shift+F6 提取变量 Extract Variable 提取方法 Extract Method 搜索 Find 查找 Find Ctrl+F Ctrl+L Ctrl+F 查找下一个 查找上一个 全局搜索","link":"/posts/fde8aecf/"},{"title":"技术&#x2F;指南&#x2F;Hexo icarus 博客维护","text":"基本指令 基本指令123456789/*npm指令*/npm install/uninstall xxx//执行package.json中定义的脚本npm run server/*hexo指令*/hexo cl && hexo g && hexo s //清理，生成，本地服务器hexo d //部署hexagon -l //查看插件 更多 Hexo 指令 传送门 Front-matter 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） excerpt 摘要 widget icarus 主题空间 标签插件 Embed 增强了 markdown 的功能的一系列插件 info: embed 语法不要包裹在反引号中，且冒号后面不要空格！！ 官方文档 官方插件文档 其他插件 探宝方法：hexo.io 搜索 embed 自己做： hexo-github-card hexo-pdf hexo-tag-bilibili hexo-tag-douban hexo-tag-bootstrap 插件 Components textcolor - Convey meaning through color with a handful of emphasis utility classes. button - Inserts a button with target links, text and specified color. ** text label - Inserts a label with text and specified color. pill - Inserts a label with text and specified color. ** text badge - Inserts a badge with text. alert - Inserts alert messages with text and specified color. card - Add a card control ** carddeck - use with cards to combine multiples ** cardgroup - similar to carddeck jumbo - jumbotron carousel - carousel tag - each img within will create a new “slide” row - add a grid row col - add a column within a grid row 使用示例 ！🐱‍🏍传送门🐱‍🏍 举亿个栗子 渲染效果因css而异 badge text alert 块级 属性：waring danger success info Best check yo self, you’re not looking too good. Change a few things up and try submitting again. You successfully read this important alert message. This alert needs your attention, but it’s not super important. textcolor （暂无css渲染） Fusce dapibus, tellus ac cursus commodo, tortor mauris nibh. Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 行内label 支持属性 default warning success danger primary info default warinng success danger primary info 行内btn 支持属性 primary success warning danger info btn btn btn btn btn btn 插入HTML来增强阅读体验 Bulma 是一个CSS框架。查看Bulma文档。 CSS 框架不包含js，涉及点击事件需要自行处理！ Note 不用js的情况下适合的组件有：button，dropdown，message Click me Overview Modifiers Grid Form Elements Components Layout More Hover me You can insert any type of content within the dropdown menu. 博客备份迁移","link":"/posts/6e7bdc/"},{"title":"技术&#x2F;语言&#x2F;Golang 避坑手册","text":"\"{\"的位置要注意 分号无 多变量声明： //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断 vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误 12345// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 默认值 并行特性：多个返回值，并行赋值 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： a = a++ // 这是不允许的，会出现变异错误 syntax error: unexpected ++ at end of statement ! Go 的自增，自减只能作为表达式使用，而不能用于赋值语句。 for each range loop !!! 函数闭包（同一个被赋予闭包函数的函数每次调用都会将匿名函数内的局部变量记忆下来） 12345678910111213141516package mainimport \"fmt\"func main() { add_func := add(1,2) fmt.Println(add_func(1,1)) fmt.Println(add_func(0,0)) fmt.Println(add_func(2,2))} // 闭包使用方法func add(x1, x2 int) func(x3 int,x4 int)(int,int,int) { i := 0 return func(x3 int,x4 int) (int,int,int){ i++ return i,x1+x2,x3+x4 }} := cannot be used globally!!! 全局变量和局部变量都有默认值 结构体与数组的匿名 append()必须要用它的返回值（原因很简单，其参数列表用的是值传递而不是指针传递） map必须要初始化（用make（）或者声明的时候直接赋值），否则只是个nil，无法对其进行赋值！！！？？ !!!GO没有隐式类型转换！！！需要灵活使用显示类型转换！ 将一个结构体赋值给一个接口变量可以想象成该接口成为了一个指向该结构体的“指针” 通道chan类型是“值相关”的，相同chan值描述同一个通道，chan用close（）关闭，）有点像file descriptor？ 两个并发线程时间前后关系不确定，同一个程序可能有不同结果 close一个chan后还能接收，不可发送","link":"/posts/c737d2b3/"},{"title":"技术&#x2F;工具&#x2F;IDEA 学习笔记","text":"IDEA基础功能概览： shortcut(edit, 代码片段, 功能), 版本控制(VCS: git, github, local history) Debug, javadoc generator, database, web deployment project&module 等概念, 模板, 项目结构查询管理 Tips 代码段：main sout标准输出 soutv输出变量，soutm输出方法名，soutp输出命令行参数 变量名.sout输出变量 iter增强型for循环 引用名.for 迭代指定引用类型 实例名.fori顺序遍历 xxx.forr倒序遍历 ifn --“if xxx is null”, inn --“if not null” xxx.nn, xxx.ifn JavaLea 条件断点 --右键断点处 ctrl+u 查看表达式的值 Tools javadoc generator: Local: zh_CN; Other command line args: encoding UTF-8 -charset UTF-8 IDE 常用快捷键对照表（原始来源: https://www.jianshu.com/p/6267a7d76018 ) 操作 eclipse IDEA Visual Studio Code Sublime 编辑 Editing 格式化代码 Format Code Ctrl+Shift+F Ctrl+Shift+L Shift+Alt+F 无 删除行 Delete Line Ctrl+D Ctrl+Y Ctrl+Shift+K Ctrl+Shift+K 复制行 Copy Line Ctrl+C Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+Shift+Up/Down Ctrl+D Alt+Shift+Up/Down Ctrl+Shift+D 移动行 Move Line Alt+Up/Down Alt+Shift+Up/Down Alt+Up/Down Ctrl+Shift+Up/Down 换行 New Line Shift+Enter Shift+Enter Shift+Enter Ctrl+Enter 插入上行 Insert Line Above Ctrl+Shift+Enter Ctrl+Alt+Enter Ctrl+Shift+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+\\ Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Alt+Shift+Up/Down Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 优化导包 Optimize Imports Ctrl+Shift+O Ctrl+Alt+O 代码提示 Code Assist Alt+/ Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Alt+/比较low Ctrl+Shift+Enter 快速修复 Quick Fix Ctrl+1 Alt+Enter Quick Access Ctrl+3 Double Shift 参数信息 Parameter Info Alt+Shift+/还不如 Alt+/ Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Alt+Shift+N Ctrl+N 激活编辑器 Active Editor F12 Esc 全部小写 Ctrl+Shift+Y 全部大写 Ctrl+Shift+X 导航 Navigation 上/下一个Tab Ctrl+PgUp/PgDn Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Alt+Left/Right Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Q Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+L Ctrl+G 大纲/结构 Outline/Structure Ctrl+O Ctrl+F12 查看类层级 Type Hierarchy Ctrl+T 查看最近文件 Recent File Ctrl+E Ctrl+F6 Ctrl+E 跳到文件 Go To File Ctrl+Shift+N 切换视图 Switch View Ctrl+F7 重构 Refator 重命名 Rename Alt+Shift+R Shift+F6 提取变量 Extract Variable Alt+Shift+L 提取方法 Extract Method Alt+Shift+M 搜索 Find 查找下一个 Ctrl+K 查找上一个 Ctrl+Shfit+K 全局搜索 Ctrl+H","link":"/posts/5a1e79ff/"},{"title":"技术&#x2F;语言&#x2F;JavaLearning","text":"2020-4-28 content: 对象与类，基本数据类型 int a, b; 则“a=b”表达式为int类型，不会自动转化为boolean类型 Java 的匿名内部类 Java12345678910111213//定义语法new 父类构造器（实参列表) | 实现接口() //必须继承一个父类或接口{ //匿名内部类的类体部分}/** * 规范： * 匿名类的声明是由java编译器自动派生自一个类实例创建表达式。 * 匿名类永远不能是抽象的。 * 匿名类总是隐式的final。 * 匿名类总是一个内部类；并且不能是static的。 */ 注意： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 内部类的class文件命名是：主类＋$＋内部类名 匿名类的class文件命名是：主类＋$＋(1,2,3…) class 对象 获取方式：有三种获得Class对象的方式： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class （类字面常量） 每个类的运行时的类型信息就是用Class对象表示的","link":"/posts/6374ed46/"},{"title":"技术&#x2F;指南&#x2F;小技巧手册","text":"每天一个避坑小技巧 解决网站元素（例如图片）加载不出来的方法 浏览器下审查该元素的URL地址，然后在搜索他的域名对应的地址（https://tools.ipip.net/domain.php） 将域名解析 “xxx.xxx.xxx.xxx 域名” 加入到hosts文件中（一般在 %SystemRoot%\\system32\\drivers\\etc\\ 目录下） cmd 下 ipconfig \\flushdns 刷新试试 刷新浏览器查看效果 SSR 解决端口占用问题： 法一：在 SSR 选项设置里改变端口 法二：taskkill /pid xxx -f","link":"/posts/fac7f463/"},{"title":"技术&#x2F;语言&#x2F;Java&amp;Kotlin语法对照","text":"Java & Kotlin 的语法片段对照 函数式 API Java 123456789101112//传入接口类型的实例（或继承了接口的匿名类）/* public interface Runnable { void Run(); } */new Thread(new Runnable() { @Override public void run() { //执行逻辑 }}).start() Kotlin 1234//传入Lambda表达式（单抽象的接口类型也可简化为Lambda表达式后传入）Thread { //执行逻辑}.start() 访问控制 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 Class 对象引用 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class","link":"/posts/7a368ad4/"},{"title":"技术&#x2F;语言&#x2F;LatexTikz","text":"Tikz 绘图学习笔记 注意事项: \\begin{tikzpicture} 环境下每一行命令结尾都要加分号; \\node, \\coordinate, \\draw 语法参考：https://zhuanlan.zhihu.com/p/84943429 \\node 描点, \\coordinate 拟点, \\draw 画线, \\fill 填充 参考网站: 路径与坐标：https://www.latexstudio.net/archives/51602.html node 控制：https://www.latexstudio.net/archives/51617.html 线条控制: https://www.latexstudio.net/archives/51622.html 示例代码: 12\\node at (A)[circle,fill,inner sep=1pt]{};% 点名 属性","link":"/posts/9b17222d/"},{"title":"技术&#x2F;语言&#x2F;Kotlin 学习笔记","text":"Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 $a 和 ${a.func()}我是真没话说。 完善的NULL检查机制 “!!, ?, ?:”（当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。方法是： “Type后 + ？”） 玩转for循环：可以方便的指定遍历的步长，范围。（ …, step, downTo, in, until) Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 支持二进制字面量，数值类型混入下划线增加语义性。 有些时候较小类型不会隐式转换成较大类型，需要手动调用 .toXXX() 来进行显示的类型转换。 和 golang 一样少了分号（这就是语法糖吗i了i了 if-else 语句与when语句等可以视为 表达式（可赋值 when 与 -> 符号构成强大的分支控制。 完全抛弃基本数据类型改用对象数据类型“。 “fun xxx() = xxx” 这个语法糖结合 if else, when 等特性可以打出漂亮的组合拳。 class 继承的时候对继承的父类后面一般要加括号（因为 java 继承中必调用父类构造函数）且此构造函数必调用著构造函数。 Java 与 Kotlin 访问修饰符对照表 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 语法糖: 原生支持数据类、单例类 （自动完成 toString(), hashCode(), equals() 等方法） 数据类对比 Java-example12345678910111213141516171819202122232425262728public class Cellphone { String brand; double price; public Cellphone(String brand, double price) { this.brand = brand; this.price = price; } @Override public boolean equals(Object obj) { if (obj instanceof Cellphone) { Cellphone other = (Cellphone) obj; return other.brand.equals(brand) && other.price == price; } return false; } @Override public int hashCode() { return brand.hashCode() + (int) price; } @Override public String toString() { return \"Cellphone(brand=\" + brand + \", price=\" + price + \")\"; }} Kotlin-example1data class Cellphone(val brand: String, val price: Double) //加一个data即可 单例类对比 Java-example12345678910111213141516public class Singleton { private static Singleton instance; private Singleton() {} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } public void singletonTest() { System.out.println(\"singletonTest is called.\"); }} Kotlin-example12345object Singleton { //只需要用object代替class即可 fun singletonTest() { println(\"singletonTest is called.\") } //这里相当于一个静态方法} Kotlin class 类 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class Kotlin 标准函数 一系列定义于 Standard.kt 里的函数 参照表 函数 特点 代码段 let() 调用let的对象作为Lamda的参数，返回最后一行 obj.let {(obj2 ->) //obj2是obj} with() 传入对象作为Lambda的上下文，返回最后一行 with(obj) {//obj上下文} run() 调用run的对象作为Lamda的上下文，返回最后一行 obj.run {//obj上下文} apply() 调用apply的对象作为Lamda的上下文，返回原对象 obj.apply {//obj上下文} Kotlin “静态方法调用” 单例类 objetc {} 伴生类 companion object {} 顶层方法 fun xxx()，可以被任意Kotlin代码直接调用，文件名作为类还可以用于java静态方法调用 @JvmStatic 注释，只能加注在单例类方法或伴生类方法上，使其编译成java静态方法","link":"/posts/ec3dabc7/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记（三）","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第九章和第十章的读书笔记，主要内容包括四大组件中的Service以及一些手机多媒体的使用。\" 为方便笔记，约定使用伪Kotlin语法： 用来表示ClassName类的一个实例 或 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法/类 或写在方法(类)前用来表示该方法（类）是一个静态的方法/类 表示public方法 O 是override的缩略 XXX 表示待定的语法字符串 ... 表示前后代码段省略 UML 图的规定： 斜体函数*为抽象函数 下划线函数$为静态函数 以下前缀代表访问权限 + Public - Private # Protected ~ Package/Internal 丰富多彩的多媒体 使用通知 概览 classDiagram class NotificationManager { +notify() +createNotificationChannel() } class NotificationChannel class NotificationCompat { +Builder() } NotificationCompat --> Notification: 创建 NotificationManager --> NotificationChannel: 创建、管理 NotificationManager --> Notification: 发送 Notification --* NotificationChannel: 对应 NotificationManager 类 创建：val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotifictionManager 备注：getSystemService() 是 Context 的一个用来获取系统服务方法。 NotificationChannel 类 每条通知都要属于一个对应的渠道。每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。 创建通知渠道12345678if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { // 通知渠道是v8.0新增的API，需要做下版本判别才能使用NotificationChannel val channel = NotificationChannel(channelId: String, channelName: String, importance) //构造通知渠道实例 渠道标识串 向用户显示的渠道名称 重要等级 .createNotificationChannel(channel) //创建通知渠道 } 通知渠道重要等级：IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN，用不同level构造的channel会有不同的表现，如HIGH级别的渠道会弹出通知。 Notification 类 可以在 Activity（较少）、Broadcast、Service 中创建 通知の构建与发送1234567891011121314//用AndroidX库的NotificationCompat类来构建通知要比原API兼容性更好val notification = NotificationCompat.Builder(context, channelId: String)//通知要对应唯一一个channel .setContentTitle(title: String) .setContentText(text: String) .setContentIntent(pi: PendingIntent)//点击事件 .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) .setAutoCancel(true)//点击通知后通知消失 //可以连缀多个set方法来赋予通知各种属性 .build()//构建 //通过管理器发送.notify(id: Int, notification: Notification)// 通知的标识符 通知 通知属性(进阶)：.setStyle() 方法——让通知呈现富文本 flowchart TD Style --> BigPictureStyle; Style --> BigTextStyle setStyle 举例12345//大图片.setStyle(NotificationCompat.BigPictureStyle().bigPicture( BitmapFactory.decodeResource(resources, R.drawable.big_image)))//长文字.setStyle( NotificationCompat.BigTextStyle().bigText(string: String) ) 点击事件 为通知设置点击事件：.setContentIntent(pi: PendingIntent) 构建PendingIntent123 PendingIntent.getXXX(ctx: Context, 0, intent: Intent, flag: Int): PendingIntent//para4用于确定PendingIntent的行为，一般可取0详，情查文档//XXX可以是Activity、Broadcast、Service 调用摄像头与相册 From Camera flowchart TB A[fa:fa-camera-retro intent机制呼出相机拍照] 获取对应的Uri对象 --> 给intent传入Uri指定相片将写入的文件 A --> 将拍摄的照片显示出来 创建对应路径的File对象 --> 获取对应的Uri对象 给intent传入Uri指定相片将写入的文件 --> A 相机实例1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : AppCompatActivity() { lateinit var imageUri: Uri lateinit var outputImage: File override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //step1 outputImage = File(externalCacheDir, \"output_image.jpg\") if (outputImage.exists()) { outputImage.delete() } outputImage.createNewFile() //step2 imageUri = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { FileProvider.getUriForFile(this, \"com.example.cameraalbumtest.fileprovider\", outputImage) } else { Uri.fromFile(outputImage) }//从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个FileUriExposedException异常。 //而FileProvider则是一种特殊的ContentProvider，它可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。 //step3~4 val intent = Intent(\"android.media.action.IMAGE_CAPTURE\") intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri) startActivityForResult(intent, takePhoto) } //step5 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { takePhoto -> { if (resultCode == Activity.RESULT_OK) {val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri)) imageView.setImageBitmap( bitmap) } } } } ...} 代码中用到\"com.example.cameraalbumtest.fileprovider\"，需要在Manifest中注册。 fileprovider注册示例123456789 res/xml/file_paths.xml文件示例12345 // 随意 指定共享目录 From Album flowchart LR 发送请求Intent-->接受并处理结果Result 相簿示例12345678910111213141516171819202122232425class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { //*step1 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT) intent.addCategory(Intent.CATEGORY_OPENABLE) intent.type = \"image/*\" startActivityForResult(intent, fromAlbum) } //step2 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { fromAlbum -> { if (resultCode == Activity.RESULT_OK && data != null) { data.data?.let { uri -> val bitmap = getBitmapFromUri(uri) imageView.setImageBitmap(bitmap) } } } } } 播放多媒体文件 音频概览 classDiagram class Activity { getAssets(); } class AssetManager { +openFd(); } class MediaPlayer { +setDataSource(); +prepare(); } Activity-->AssetManager: 创建 AssetManager-->MediaPlayer: 提供播放资源 MediaPlayer 类 MediaPlayer 可以用于播放网络、本地、app安装包中的音频 方法名 功能描述 setDataSource() 设置要播放的音频文件的位置 prepare() 在开始播放之前调用，以完成准备工作 start() 开始或继续播放音频 pause() 暂停播放音频 reset() 将MediaPlayer对象重置到刚刚创建的状态 seekTo() 从指定的位置开始播放音频 stop() 停止播放音频。调用后的MediaPlayer对象无法再播放音频 release() 释放与MediaPlayer对象相关的资源 isPlaying() 判断当前MediaPlayer是否正在播放音频 getDuration() 获取载入的音频文件的时长 AssetManager 类 app/src/main/assets 内的文件和子目录在项目打包时会一并打包到安装文件中。 AssetManager 就是用来管理asset内文件的工具类 音频示例 播放安装包内音频12345678910111213141516171819202122232425262728293031323334353637383940class MainActivity : AppCompatActivity() { private val mediaPlayer = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initMediaPlayer() play.setOnClickListener { if (!mediaPlayer.isPlaying) { mediaPlayer.start() // 开始播放 } } pause.setOnClickListener { if (mediaPlayer.isPlaying) { mediaPlayer.pause() // 暂停播放 } } stop.setOnClickListener { if (mediaPlayer.isPlaying) { mediaPlayer.reset() // 停止播放 initMediaPlayer() } } } private fun initMediaPlayer() { val assetManager = assets val fd = assetManager.openFd(\"music.mp3\") mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length) mediaPlayer.prepare() } override fun onDestroy() { super.onDestroy() mediaPlayer.stop() mediaPlayer.release() }} 视频概论 VideoView 类实际上是在MediaPlayer上的一层封装。 注意VideoView不支持播放asset文件，但可以播放app/src/main/res/raw下的文件（想到VideoView是一种View就不难理解）。 注意VideoView不适合做功能强大的视频播放器。 视频实例 VideoView控件12345 VideoView类123456789101112131415161718192021222324252627282930313233/*class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)*/ val uri = Uri.parse(\"android.resource://$packageName/${R.raw.video}\") //留意资源URI字符串格式 videoView.setVideoURI(uri) /* play.setOnClickListener { if (!videoView.isPlaying) { videoView.start() // 开始播放 } } pause.setOnClickListener { if (videoView.isPlaying) { videoView.pause() // 暂停播放 } } replay.setOnClickListener { if (videoView.isPlaying) { videoView.resume() // 重新播放 } } }*/ override fun onDestroy() { super.onDestroy() videoView.suspend()//释放VideoView占用的资源 }} 后台默默劳动者 Service 安卓多线程 Kotlin 多线程编程 kotlin创建线程的三种方式123456789101112131415161718//1. 继承重写Thread()class MyThread: Thread() { override fun run() {...}}MyThread.start()//2-1. 用接口构造Thread()Thread(object: Runnable { //注意这里是匿名内部类的写法 override fun run() {...}}).start()//2-2. kotlin单抽象方法接口の简化版Thread{/*Lambda*/}.start()//3. 用kotlin内置顶层函数thread { //logic} 异步消息处理机制 Android 只能在主线程中改UI，因此在子线程中想要进行UI操作就需要异步机制 Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。 Handler主要用于发送和处理消息，发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。 MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象。 异步消息处理机制实例123456789101112131415161718192021222324252627class MainActivity : AppCompatActivity() { val updateText = 1 //在主线程中创建一个Handler对象，当接收到Message时该对象的.handleMessage()就能在主线程中被调用 val handler = object : Handler() { override fun handleMessage(msg: Message) { // 在这里可以进行UI操作 when (msg.what) { updateText -> textView.text = \"Nice to meet you\" } } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) changeTextBtn.setOnClickListener { thread { val msg = Message() msg.what = updateText handler.sendMessage(msg) // 在子线程将Message对象发送出去 } } }//一趟下来Message从子线程辗转到了主线程} classDiagram class Message { Int what Int arg1 Int arg2 Object obj } class Handler { +sendMessage(Message m) +post() +handleMessage(Message m)* } Handler --> Message: 发送 Message --> Handler: 处理 AsyncTask 类 重写四个方法，.execute()启动 解析AsyncTask类12345678 AsyncTask {//注意三个泛型：参数类型 进度类型 结果类型 onPreExecute() //后台开启前的初始化任务 doInBackground(paramsType...) //后台任务：在子线程中运行 onProgressUpdate(progressType...) //后台publishProgress(progressType...)后执行（通常在这改UI） onPostExecute(resultType) //后台return后执行 execute() //启动任务} Service 基础 Service 类 Service类解析123456class Service { onCreate() //创建时调用（第一次.startService, bindService） onStartCommand(intent: Intent, flags: Int, startId: Int) //启动时调用(startServi...) onDestroy() //销毁时调用(stopService, unbindService) onBind(): IBinder //返回一个绑定接口便于Activity与Service交互} 创建、启动与销毁 Activity中启动与停止Service1234567startServiceBtn.setOnClickListener { val intent = Intent(this, MyService::class.java) startService(intent) // 启动Service，会同时调用.onCreate和onStartCommand}stopServiceBtn.setOnClickListener { val intent = Intent(this, MyService::class.java) stopService(intent) // 停止Service Binder 类 继承一个Binder，在类中编写自己的函数，通过onBind() 返回该实例给Activity，Activity中调用该实例的方法以实现Activity与Service的通信 classDiagram class IBinder IBinder class MyBinder { } IBinder |停止服务| stopService+unbindService A(同一个Service类只会存在一个实例) 前台服务 Foreground 前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。 由于状态栏中一直有一个正在运行的图标，相当于我们的应用以另外一种形式保持在前台可见状态，所以系统不会倾向于回收前台Service。 启用方式：在.onCreat()中创建一条通知，大体上与1.1中创建通知的方式一样，不同的是不用通知管理器发送通知而是以startForeground(…)发送通知。 应用开启前台服务权限12345 … 前台服务实例12345678910111213141516171819202122class MyService : Service() { … override fun onCreate() { super.onCreate() val manager = getSystemService(Context.NOTIFICATION_SERVICE) asNotificationManager if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { val channel = NotificationChannel(\"my_service\", \"前台Service通知\", NotificationManager.IMPORTANCE_DEFAULT) manager.createNotificationChannel(channel) } val intent = Intent(this, MainActivity::class.java) val pi = PendingIntent.getActivity(this, 0, intent, 0) val notification = NotificationCompat.Builder(this, \"my_service\") .setContentTitle(\"This is content title\") .setContentText(\"This is content text\") .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.large_icon)) .setContentIntent(pi) .build() startForeground(1, notification) } …} IntentService 类 classDiagram class IntentService { onHandleIntent(Intent intent)* } class MyIntentService { } class Service { } Service","link":"/posts/87cffae2/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记 (一)","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第一章到第五章的读书笔记，讲了AS的基本使用方法和Android项目结构，四大组件之一的Activity，以及各种UI控件的编写，还收录了本书中涉及的Kotlin的语法特性\" 第一章 开启征程（概要） 项目结构与目录：page 17 - page 19 Log 方法与 Logcat 的完美结合 第二章 Kotlin 语法糖 同《Kotlin 学习笔记》一同食用更佳！ 《第一行》中出现的 Kotlin 特性预览表 主次构造函数 参数默认值 键值对传参 字符串内嵌表达式 init {}, constructor () {} fun xxx(str: String = \"\") {...} xxx(str = \"...\") \"${value}\" 标准函数 Lambda 表达式 空指针检查 函数式 API let, run, apply, with {para -> ...}, {it.toString()} ? ?. !!. ?: map.maxby {/*Lambda*/} 容器初始化 数据类 单例类 循环遍历 listOf(), mapOf(), setOf() data object for-in, until, downTo, step, l...r,容器遍历 分支控制 条件控制 “不变为先” 访问控制 when () {... -> ...}, if-else 语句/表达式 is (instanceof), else val, var, open class \"public by default\" 类型强转 repeat 函数 运算符重载 延迟初始化 as, as? repeat(/*num*/) {/*Lambda*/} operator 关键字 lateinit 初始化判断 密封类（与when语句一同使用） 扩展函数 无用参数 ::($变量名).isInitialized sealed class fun ClassName.funcName(...) : ... {} 下划线_ 函数类型 高阶函数 内联函数 可变参数 ClassName.(paraType, ...) -> returnType 接受/返回函数类型/Lambda表达式的函数 inline noinline crossinline vararg Pair 类型 Smart Cast 自动转型 泛型 委托 A to B， 泛型 is Type 判断后实例自动向下转换类型 类委托、属性委托 第三章 Activity！所见即所得 创建 Activity 创建和加载布局文件 layout 在 AndroidManifest.xml 中注册Activity 编写 Activity.kt 代码 （事件绑定，方法重写等） Activity 通信与切换 Intent 类 显式切换：Intent(上下文, 指定Activity 的 Class 类) 隐式切换：指定 action category，目标将会按照注册信息中的过滤条件响应 intent。 过滤条件： 传参：.putExtra(), .getStringExtra() 启动方式：startActivity() //普通启动 startActivityForResult() //请求结果 - Activity 类 Result 结果 设置结果：setResult() 取回结果：override onActivityResult() Bundle 类 团队合作时用伴生类“静态方法”来启动 Activity 生命周期 返回栈的概念 思维导图 保存信息 Bundle 类型 onSaveInstanceState()，var savedInstanceState Activity 启动模式 standard 无检查，直接压栈 singleTop 检查栈顶 singleTask 解栈恢复 singleInstance 创建新栈 第四章 UI！！ 门面功夫 😃 控件 Widget 基本控件：TextView，EditView，Button，…… 自定义控件：编写class（注入布局，绑定事件）→\\rightarrow→ xml注册引入自定义控件 →\\rightarrow→ 引入控件 高级一点的控件：ListVIew, RecyclerView … 基本原理撇清楚 Inflater 的作用：将xml格式的布局文件解析转化成View的实例 findViewById() 返回布局中指定id的View实例, 在Activity类中直接使用findViewById()相当于在当前Activitiy所加载的布局中寻找对应的view，而使用view.findViewById()则指定了寻找的区域是view内 留意Kotlin自动类型推导机制的使用场合，方法 *第五章 手机平板要兼顾，探究Fragment 学习内容 Frag 生命周期，Frag 动态加载布局","link":"/posts/37a431d8/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记 (二)","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第六章到第八章的读书笔记，主要内容包括Android数据存储（持久化技术），四大组件中的Broadcast广播系统以及ContentProvider内容提供商\" 为方便笔记，约定使用一下伪Kotlin语法： 用来表示ClassName类的一个实例 或 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法 XXX 表示待定的语法字符串 ... 表示前后代码段省略 第六章 全局大喇叭！详解广播机制 监听/接受广播 静态/动态注册BroadcastReciever，注意静态注册的接收器不能接受隐式Intent，还缺乏Activity上下文，但是能够在没启动的情况下收听到广播信号 静态注册：Manifest中注册；动态注册：Activity中注册，要记得自行销毁 发送自定义广播 Intent可以不但可以穿梭于不同Activity之间，也可以穿梭于不同Application之间（Broadcast） 分类：标准广播（一传多），有序广播（one by one，可截断） 第七章 数据存储：告别不持久 Java流基础知识 文件存储 适合存储一些简单的文本数据或二进制数据 Context 类提供 openFileOutput(...), openFileInput(...)用来打开（创建）一个/data/data//files/目录下的文件，方法返回一个FileOutPutStream或FileInputStream对象，该对象可使用 Java流 的方式IO 举例：FileOutPut - OutputStreamWriter - BufferedWriter 文件存储实例1234567891011fun save(inputText: String) { try { val output = openFileOutput(\"data\", Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) writer.use { it.write(inputText) } } catch (e: IOException) { e.printStackTrace() }} SharedPreferences 存储 SharedPreferences 是使用键值对的方式来存储数据的，支持多种数据类型的存储 获取SharedPreferences: Context 的 getSharedPreferences() Activity 的 getPreferences() 存储步骤 调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。 调用apply()方法将添加的数据提交，从而完成数据存储操作。 KTX库方法： KTX简化SharedPreferences存储1234getSharedPreferences(\"data, Context.MODE_PRIVATE\").edit { putString(\"name\", \"Tom\") putInt(\"age\", 28)} SQLite数据库存储 SQLite 是一种轻量简便的关系型数据库，可以用来存储复杂关系的数据 SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级（需要重写onCreate(), onUpgrate()） 两种CRUD方式：SQLiteDataBase类成员函数；SQL语句执行。 KTX库：contentValuesOf() 方法 数据库文件存储路径：/data/data//databases/下 创建数据库 继承一个SQLiteOpenHelper的帮助类 解析SQLiteHelper帮助类12345678910111213141516//构造方案之一SQLiteOpenHelper(context: Context, name: String, cursor: Cursor, version: Int) { // 上下文; 数据库名; 查询数据时用，一般传null; 版本号; /*抽象方法*/ override fun onCreate(db: SQLiteDatabase) { /*创建数据库时（name指定的数据库不存在时）调用*/ } override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) { /*升级数据库时（version改变时）调用*/ } /*两个重要的实例方法*/ getReadableDatabase() getWritableDataBase() //打开（没有则创建）帮助类指定的数据库，返回一个可对数据库进行读写的对象(SQLiteDataBase)。当数据库不可写入时Readable将以只读方式打开，Writable将异常 //注意Kotlin中可以直接调用readableDatabase、writableDataBase属性} 可以使用AS的Device File Explore和Database Navigate插件浏览虚拟机中的文件和数据库 升级数据库 改变SQLiteOpenHelper类的version: Int参数，则下一次打开数据库的时候（用getReadableDatabase() getWritableDataBase()）会调用onUpgrade()方法。 最佳编写方式：针对不同版本编写不同逻辑 最佳实例12345678override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) { if (oldVersion","link":"/posts/c484d1a3/"}],"tags":[{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"搜索算法","slug":"搜索算法","link":"/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"指南","slug":"技术/指南","link":"/categories/%E6%8A%80%E6%9C%AF/%E6%8C%87%E5%8D%97/"},{"name":"开发","slug":"技术/开发","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"},{"name":"语言","slug":"技术/语言","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"技术/工具","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"},{"name":"笔记","slug":"技术/笔记","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"}]}