{"pages":[{"title":"About","text":"","link":"/about/"},{"title":"Category","text":"","link":"/categories/"},{"title":"Repositories","text":"","link":"/repository/"},{"title":"books","text":"","link":"/books/"},{"title":"Gallery 画廊","text":"🌏颅内世界 以下图片来源于 wallhaven.cc","link":"/gallery/"},{"title":"Tag","text":"","link":"/tags/"},{"title":"share","text":"","link":"/share/"}],"posts":[{"title":"杂项&#x2F;Ideas","text":"Williams’s Fantastic Ideas Github 有一个叫做 app ideas 的仓库有很多好的项目 根据图片定位到视频中的某一帧","link":"/posts/853a41fd/"},{"title":"杂项&#x2F;DiscreteMathematicNote","text":"Discrete MatheMatic Note 离散数学笔记 Author: BAIDI Date: from 2020-2-19 1 Logic and Proofs 逻辑和证明 1.1 Propositional Logic connectives 逻辑联结词 negation conjunction(合取) disjunction(析取) --inclusive/exclusive … conditional statement/biconditional statement 1.2 Applications of Propositional Logic System Specification 系统规范说明 Boolean Logic 布尔逻辑 Logic Puzzles 逻辑谜题 Logic Circuits 逻辑电路 1.3 Propositional Equivalences tautology, contradiction, contingency logically equivalent ≡ ⇔ Law De Morgan’s Law ¬(p ∧ q) ≡ ¬p ∨ ¬q ¬(p ∨ q) ≡ ¬p ∧ ¬q other Law(check relative table) ¬p ∨ q and p → q Distribute Law p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r) Law’s extension Law’s application Proposition’s Satisfiability and Problem’s Solution Soduka Puzzle’s solution 1.4 Predicates and Quantifiers 谓词和量词 Predicates 谓词 basic notion:Propositional function P (命题函数P) n-place / n-ary predicates (n位/元谓词) 包含多个变量的谓词 P(x1, x2…xn) --谓词+变量=命题 Application–verify the correctness of a programme: Precondition(input) &amp; Postcondition(output expected) (前置条件 &amp; 后置条件） Quantifiers 量词 Notions: Quantification 量化 Universal quantifier 全称量词 domain: domain of discourse 论域(universe of discouse 全体域) counterexample 反例 Existential quantifier 存在量词 Precedence 优先级 Resticted Domains 约束域 (约束域和条件，合取的等价关系) bound (被赋值或被量词联结）-绑定 scope -作用域 free -自由(未绑定的变量) Logic Equivalences Involving Quantifiers Notions: comma 逗号 Prolog --programming in logic Prolog fact / Prolog rule semicolon 分号 Nested Quantifiers 嵌套变量 Rules of inference 推理规则 argument 论证 valid 有效性 premise 前提 fallacy 谬误 argument form 推理形式 modus ponens 假言推理 （law of detachment 分离规则） hypothesis 假设 syllogism 三段论 contrapositive 逆否命题 instantiation 实例 arbitrary 任意的 Itroduction to Proofs theorem 定理 axiom 公理 lemmma 引理 corollary 推论 conjecture 猜想 vacuous proof 空证明 trivial proof 平凡证明","link":"/posts/b8e16674/"},{"title":"算法&#x2F;回合制战斗","text":"一小道C语言题带来的乐趣 要用游戏的玩法打败游戏的情景题! 对于以下题目： 某游戏规则中，甲乙双方每个回合的战斗总是有一方胜利，一方失败。游戏规定：失败的一方要把自己的体力值的1/4加给胜利的一方。例如：如果双方体力值当前都是4，则经过一轮战斗后，双方的体力值会变为：5，3。现在已知：双方开始时的体力值甲：1000，乙：2000。假设战斗中，甲乙获胜的概率都是50%，求解：双方经过4个回合的战斗，体力值之差小于1000的理论概率。 用基础模拟算法来解决： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define all 16//所有可能的结果数目int exchange(double * x,double * y) //x为吸收血量方 { double t; t=(*y)*0.25;(*x)+=t;(*y)-=t; return 0; } int main(){ int js=0; double x=1000,y=2000; //美好的游戏模拟开始了 for(int i=0;i&lt;=1;i++) { double ax=x,ay=y;//存档，防止数据丢失 i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); //i判断甲（x）是否赢得一回合，并改变血条 for(int i=0;i&lt;=1;i++) { double bx=x,by=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double cx=x,cy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); for(int i=0;i&lt;=1;i++) { double dx=x,dy=y; i?exchange(&amp;x,&amp;y):exchange(&amp;y,&amp;x); if(x-y&lt;1000&amp;&amp;x-y&gt;-1000) js++; x=dx;y=dy; //重新读档，开始下一轮模拟 } x=cx;y=cy;//读档，余同 } x=bx;y=by; } x=ax;y=ay; } printf(\"四回合后体力值差&lt;1000的理论概率:\\n%f\",js*1.0/all); return 0;} 是不是特像打游戏刷关呢?( ^ v ^ )","link":"/posts/aee17ffb/"},{"title":"算法&#x2F;序列标注之HMM与CRF模型","text":"机器学习 HMM CRF 绪论 ​ 从文本翻译到文字、语音识别，再到命名实体识别，词性标注，序列标注问题已然渗透到社会生活中的方方面面。不少自然语言处理的问题都可以想方设法转化为序列标注问题：对邮件等”大块“的信息做命名实体识别，识别出信息中的表单项用于自动填写表单，可以有效地提高工作效率，节约时间；对音频文件进行标注分析，可以用来进行语音识别；抽取出来的电子病历文本中的疾病、治疗、检查等类型的实体，可以用以对电子病历进行分类归档…想要处理好一般性的自然语言处理问题到序列标记问题的转化，关键在于处理好如何定义标记的问题。 ​ 作为自然语言处理中常见的问题之一，序列标注问题已经由来已久，并在经历了一系列的发展变革后逐渐壮大健全。最早的有传统的隐马尔可夫模型、最大熵模型和条件随机场模型，最大熵模型抛弃了隐马尔科夫模型的独立输出假设，而条件随机场模型又在最大熵模型的基础上进一步将标签的转移扩大为全局特征，使得上下文之间的联系更加紧密。无论是在理论还是实践结果上来看，条件随机场的整体效果都要优于前两种方法。步入深度学习发展的时代后，新的诸如RNNRNNRNN和LSTMLSTMLSTM模型也相继用于序列标注问题，有效地改善了传统方法在处理更长的上下文依赖、过拟合、依赖启发式知识等方面的不足之处。本文主要研究和探讨了传统的序列标注模型——隐马尔可夫模型和条件随机场模型——的理论基础和应用实践。 正文 定义 ​ 序列标注是指将输入的一串观测序列 x1x2x3...xnx_1x_2x_3...x_nx1​x2​x3​...xn​ 转化为一串标记序列 y1y2y3...yny_1y_2y_3...y_ny1​y2​y3​...yn​ 的过程，要解决序列标记问题，实际上就是要找到一个观测序列到标记序列的映射 f(xi)→yi (i=1,2,...,n)f(x_i)\\rightarrow y_i\\space (i=1,2,...,n)f(xi​)→yi​ (i=1,2,...,n)。 HMM模型 马尔可夫链 马尔可夫链（Markov chain）1，又称离散时间马尔可夫链，为状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。 ​ 从数学形式上来看，对于随机变量序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−1=xn−1)P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})=P(X_n=x_n|X_{n-1}=x_{n-1}) P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)=P(Xn​=xn​∣Xn−1​=xn−1​) ，则称该序列为一个一阶马尔可夫链。 ​ 从宏观意义上来看，Markov链说明了在状态转移过程中，“未来”与“过去”无关而只与“现在”有关。 ​ Markov链常常被认为是时齐的，即转移概率与n无关。 ​ 类似的可以定义m阶Markov链，满足 P(Xn=xn∣X1=x1,X2=x2,X3=x3...,Xn−1=xn−1)=P(Xn=xn∣Xn−m=xn−m,Xn−m+1=xn−m+1...,Xn−1=xn−1)\\begin{aligned} &amp;P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3...,X_{n-1}=x_{n-1})\\\\ =&amp;P(X_n=x_n|X_{n-m}=x_{n-m},X_{n-m+1}=x_{n-m+1}...,X_{n-1}=x_{n-1}) \\end{aligned} =​P(Xn​=xn​∣X1​=x1​,X2​=x2​,X3​=x3​...,Xn−1​=xn−1​)P(Xn​=xn​∣Xn−m​=xn−m​,Xn−m+1​=xn−m+1​...,Xn−1​=xn−1​)​ 隐马尔可夫模型 ​ 隐马尔可夫模型（Hidden Markov Model 缩写：HMM）基于Markov链，不同与一般的Markov链，HMM 又加入了隐变量这一概念，即该模型包含了观测序列X1X2X3...XnX_1X_2X_3...X_nX1​X2​X3​...Xn​和与它一一对应的标记序列Y1Y2Y3...YnY_1Y_2Y_3...Y_nY1​Y2​Y3​...Yn​。该模型用到了两个基本假设： 时齐的Markov性假设，如2.2.1所述 独立输出假设，输出状态的概率仅与输入状态相关，而与输入序列的前后文无关 以图形表示的隐马尔可夫模型如下所示： HMM 模型解决了被用来解决序列标注问题中的三个基本问题：预测、平滑和解码。本文主要讨论的解码问题，即求解给定观测序列，给出最有可能的标记序列的问题。本文使用λ(W,T,π,β,A,B)\\lambda(W,T,\\pi,\\beta,A,B)λ(W,T,π,β,A,B)来表征一个序列标注问题的HMM模型，其中WWW表示观测序列，TTT表示输出的标记序列，π\\piπ表示标记之间的概率转移转移矩阵，β\\betaβ表示标记到观测值的发射概率，AAA表示输入对象的集合，BBB表示标记的集合。 概率模型 问题归结于求解下式 argTmax P(T=t1t2...tn∣W=w1w2...wn,λ)(ti∈B,wi∈A)(1)arg_{T}max\\space P(T=t_1t_2...t_n|W=w_1w_2...w_n,\\lambda)\\qquad (t_i\\in B, w_i\\in A)\\tag{1} argT​max P(T=t1​t2​...tn​∣W=w1​w2​...wn​,λ)(ti​∈B,wi​∈A)(1) 由贝叶斯概率公式 P(T∣W)=P(W∣T)P(T)P(W)∝P(W∣T)P(T)(2)P(T|W)=\\frac{P(W|T)P(T)}{P(W)}\\propto P(W|T)P(T)\\tag{2} P(T∣W)=P(W)P(W∣T)P(T)​∝P(W∣T)P(T)(2) 因为 P(W)=constP(W)=constP(W)=const 故而可以省略不予以考虑 由独立输出假设可知 P(W∣T)=P(w1∣t1)P(w2∣t2)...P(wn∣tn)(3)P(W|T)=P(w_1|t_1)P(w_2|t_2)...P(w_n|t_n)\\tag{3} P(W∣T)=P(w1​∣t1​)P(w2​∣t2​)...P(wn​∣tn​)(3) 由一阶时齐的Markov性假设可知 P(T)=P(t1)P(t2∣t1)P(t3∣t2)...P(tn∣tn−1)(4)P(T)=P(t_1)P(t_2|t_1)P(t_3|t_2)...P(t_{n}|t_{n-1})\\tag{4} P(T)=P(t1​)P(t2​∣t1​)P(t3​∣t2​)...P(tn​∣tn−1​)(4) 联立方程 (2)(3)(4)⇒(2)(3)(4)\\Rightarrow(2)(3)(4)⇒ P(T∣W)∼[P(t1)P(w1∣t1)][P(t2∣t1)P(w2∣t2)]...[P(tn∣tn−1)P(wn∣tn)](5)P(T|W)\\sim [P(t_1)P(w_1|t_1)][P(t_2|t_1)P(w_2|t_2)]...[P(t_n|t_n-1)P(w_n|t_n)]\\tag{5} P(T∣W)∼[P(t1​)P(w1​∣t1​)][P(t2​∣t1​)P(w2​∣t2​)]...[P(tn​∣tn​−1)P(wn​∣tn​)](5) 其中转移概率由条件概率公式可知 P(ti∣ti−1)=P(ti,ti−1)P(ti−1)(6)P(t_i|t_{i-1})=\\frac{P(t_i,t_{i-1})}{P(t_{i-1})}\\tag{6} P(ti​∣ti−1​)=P(ti−1​)P(ti​,ti−1​)​(6) 等式(6)(6)(6)中标记值的概率和等式(5)(5)(5)中的独立输出概率可由统计方法或规则方法得出，下面介绍两种方法的异同： 项目 统计方法 规则方法 介绍 通过统计得出频率估计概率的方法 通过既定的规则来估计概率的方法 优点 覆盖面广，稳定性高 精确，对于特殊现象的支持度好 缺点 对于特殊现象的支持度差 规则库庞大，编写和维护复杂，覆盖面不及统计方法 能够计算出特定T∗T^*T∗的概率值P(T∗∣W)P(T^*|W)P(T∗∣W)还不够，还要要找到最大的概率对应的TTT。这个问题可以转化成一个求解最短加权路径的图论问题。 可构建像 graph 1 所示的图模型（其余路径未画出）。显然，如果标记的取值有mmm种可能，序列的长度为nnn，那么枚举所有路径然后取加权值最大的路径的算法复杂度为 O(nm)O(n^m)O(nm) ，随着序列长度增长而呈指数级增长。为了降低复杂度这里一般采用维特比算法 (Viterbi algorithm) 。 The Viterbi algorithm2 is a dynamic programming algorithm for finding the most likely sequence of hidden states—called the Viterbi path—that results in a sequence of observed events, especially in the context of Markov information sources and hidden Markov models (HMM). 维特比算法是一种动态规划算法，用于找出隐藏的最大可能路径（维特比路径）。维特比算法的核心思想在于全局最优包含局部最优。考虑从起点到某个中间点的最大加权路径，那么该路径所经过的该中间点的前一个点在同时间上所有点中也一定是加权最大的点。下面给出了Viterbi算法的伪代码。其中T1,T2T_1,T_2T1​,T2​分别为保存当前节点最大累计权值的矩阵和保存该节点最大累计权值路径上的上一个节点的矩阵。以下给出了维特比算法的算法伪代码： 下溢问题：(5)(5)(5) 式中的连乘积中因子有可能过小而下溢为零从而造成整个式子变为0，为了避免这种情况可以考虑取对数化乘积为加法的技巧。 应用 ​ 绝大多数自然语言处理问题（Natural Language Processing Problem，简称NLP问题），都可以转化为一个序列标注问题。想要处理好NLP问题到序列标记问题的转化关键在于处理好如何定义标记的问题。例如对于中文分词问题，可以定义标签集合 T={B,M,E,S}T=\\{B,M,E,S\\}T={B,M,E,S} ，其中 B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single)B(begin),M(middle),E(end),S(single) 分别表示词的开头，中间，结尾和单个字成词；对于词性标注问题，可以在分词处理的基础上让一个词对应一个词性标签。对于命名实体识别问题，可以定义标签集合 T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N}T=\\{BL,ML,EL,BP,MP,EP,BO,MO,EO,N\\}T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N} 其中 B,M,EB,M,EB,M,E 后面跟着的 L(location),P(person),O(organization)L(location),P(person),O(organization)L(location),P(person),O(organization) 分别表示地名，人民，机构名，而 NNN 表示不属于实体的部分。定义好标记之后输入训练好的模型后问题即可求解。 CRF 模型 随机场、马尔可夫随机场、条件随机场 ​ 考虑一个空间内各个区域按照某种分布被赋予了某个随机值，这样的场称之为“随机场”。而马尔可夫随机场则是一类特殊的随机场，场中每个点的赋值不仅与自身位置有关，还和相邻位置的赋值相关。如果考虑马尔科夫性的同时将点的赋值概率看做是条件概率，则称该马尔科夫场为条件随机场（Conditional random fields 简称：CRF）。如维基百科3中所述: Whereas a classifier predicts a label for a single sample without considering “neighboring” samples, a CRF can take context into account. ​ CRF模型和那些仅仅只考虑自身来进行分类的模型不同之处就在于CRF模型将样本点的“邻居”也考虑在内，这个特点使得CRF模型有能力处理上下文有关联的序列标注的问题。 线性链条件随机场 线性链的条件随机场（Linear conditional random fields）是对条件随机场的简化模型：X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn)X=(X1,X2,...Xn),Y=(Y1,Y2,...Yn) 均为线性链表示的随机变量序列，在给定随机变量序列XXX的情况下，随机变量YYY的条件概率分布 P(Y∣X)P(Y|X)P(Y∣X) 构成条件随机场，即满足马尔科夫性： P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7)P(Yi|X,Y1,Y2,...Yn)=P(Yi|X,Yi−1,Yi+1)\\tag{7} P(Yi∣X,Y1,Y2,...Yn)=P(Yi∣X,Yi−1,Yi+1)(7) 则称 P(Y∣X)P(Y|X)P(Y∣X) 为线性链条件随机场。 概率模型 ​ 为了建立可供学习的CRF模型，可以定义两类特征函数（这些特征函数用来评价一个序列在某些特征方面是否“靠谱”，只有 1,01, 01,0 两种取值，即判断是否满足条件）：一类只与当前节点有关，表示为sl(yi,x,i) (l=1,2...,m)s_l(y_i,x,i)\\space (l=1,2...,m)sl​(yi​,x,i) (l=1,2...,m)；另一类还与前一个节点有关，表示为tk(yi−1,yi,x,i) (k=1,2...,n)t_k(y_{i-1},y_i,x,i)\\space (k=1,2...,n)tk​(yi−1​,yi​,x,i) (k=1,2...,n)。引入需要学习的权重参数（所谓“权重”即用来衡量一个判断依据的重要程度的参数）λl,μk\\lambda_l,\\mu_kλl​,μk​，则条件概率表示为 P(y∣x)=1Z(x)exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))∝exp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(8)\\begin{aligned} P(y|x)&amp;=\\frac{1}{Z(x)}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\\\ &amp;\\propto exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i)) \\end{aligned}\\tag{8} P(y∣x)​=Z(x)1​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))∝exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))​(8) Z(x)Z(x)Z(x)为规范化因子，是所有可能的标注序列的概率和，使得等式右边规范为一个概率。 Z(x)=∑yexp(∑i,kλktk(yi−1,yi,x,i)+∑i,lμlsl(yi,x,i))(9)Z(x)=\\sum_{y}exp(\\sum_{i,k}λ_kt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μ_ls_l(y_i,x,i))\\tag{9} Z(x)=y∑​exp(i,k∑​λk​tk​(yi−1​,yi​,x,i)+i,l∑​μl​sl​(yi​,x,i))(9) 为了使得表示更加方便，将参数 λ,μ\\lambda,\\muλ,μ 均表示为 www ，特征函数 t,st, st,s 均表示为 fff ，即有 wk={λk(0&lt;k⩽m)μk−m(m&lt;k⩽m+n)(10)w_{k}=\\left\\{ \\begin{aligned} &amp;\\lambda_k\\qquad &amp;(0 &lt; k \\leqslant m)\\\\ &amp;\\mu_{k-m}\\qquad &amp;(m &lt; k \\leqslant m+n) \\end{aligned}\\tag{10} \\right. wk​={​λk​μk−m​​(0&lt;k⩽m)(m&lt;k⩽m+n)​(10) fk(y,x)={∑isk(yi,x,i)(0&lt;k⩽m)∑itk−m(yi−1,yi,x,i)(m&lt;k⩽m+n)(11)f_{k}(y,x)=\\left\\{ \\begin{aligned} &amp;\\sum_{i}s_k(y_i,x,i)\\qquad &amp;(0 &lt; k \\leqslant m)\\\\ &amp;\\sum_{i}t_{k-m}(y_{i-1},y_i,x,i)\\qquad &amp;(m &lt; k \\leqslant m+n) \\end{aligned}\\tag{11} \\right. fk​(y,x)=⎩⎪⎪⎨⎪⎪⎧​​i∑​sk​(yi​,x,i)i∑​tk−m​(yi−1​,yi​,x,i)​(0&lt;k⩽m)(m&lt;k⩽m+n)​(11) 由 (11)(12)(11)(12)(11)(12) 式可将 (8)(8)(8) 式简化为 P(y∣x)=exp(∑kwkfk(y,x))∑yexp(∑kwkfk(y,x))∝exp(∑kwkfk(y,x))(12)P(y|x)=\\frac{exp(\\sum_k w_kf_k(y,x))}{\\sum_yexp(\\sum_k w_kf_k(y,x))}\\tag{12} \\propto exp(\\sum_k w_kf_k(y,x)) P(y∣x)=∑y​exp(∑k​wk​fk​(y,x))exp(∑k​wk​fk​(y,x))​∝exp(k∑​wk​fk​(y,x))(12) 参数学习 以下采用梯度下降法来训练参数。 定义损失函数 L=−M=−log∏x,yP(y∣x)P‾(x,y)=−∑x,yP‾(x,y)logP(y∣x)=∑xP‾(x)logZ(x)−∑x,yP‾(x,y)∑kwkfk(y,x)=∑xP‾(x)log∑yexp(∑kwkfk(y,x))−∑x,yP‾(x,y)∑kwkfk(y,x)(13)\\begin{aligned} L&amp;=-M\\\\ &amp;=-log\\prod_{x,y}P(y|x)^{\\overline{P}(x,y)}\\\\ &amp;=-\\sum_{x,y}\\overline{P}(x,y)logP(y|x)\\\\ &amp;=\\sum_{x}\\overline{P}(x)logZ(x)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x)\\\\ &amp;=\\sum_{x}\\overline{P}(x)log\\sum_{y}exp\\big(\\sum_k w_kf_k(y,x)\\big)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x) \\end{aligned}\\tag{13} L​=−M=−logx,y∏​P(y∣x)P(x,y)=−x,y∑​P(x,y)logP(y∣x)=x∑​P(x)logZ(x)−x,y∑​P(x,y)k∑​wk​fk​(y,x)=x∑​P(x)logy∑​exp(k∑​wk​fk​(y,x))−x,y∑​P(x,y)k∑​wk​fk​(y,x)​(13) 其中P‾\\overline{P}P为先验概率，可以通过统计方法得出。 对损失函数求导可得： ∂L∂wk=∑x,yP‾(x)P(y∣x)fk(y,x)−∑x,yP‾(x,y)fk(y,x)(14)\\frac{\\partial L}{\\partial w_k}=\\sum_{x,y}\\overline{P}(x)P(y|x)f_k(y,x)-\\sum_{x,y}\\overline{P}(x,y)f_k(y,x)\\tag{14} ∂wk​∂L​=x,y∑​P(x)P(y∣x)fk​(y,x)−x,y∑​P(x,y)fk​(y,x)(14) 有了损失函数的导数之后就可以进行迭代优化参数，直到达到收敛条件： wk:=wk−η⋅∂L∂wk(15)w_k:=w_k-\\eta\\cdot\\frac{\\partial L}{\\partial w_k}\\tag{15} wk​:=wk​−η⋅∂wk​∂L​(15) 梯度下降法的算法流程为：定义损失函数 L(w)L(w)L(w)、学习率 η→\\eta\\rightarrowη→计算梯度 ∂L∂wk→\\frac{\\partial L}{\\partial w_k}\\rightarrow∂wk​∂L​→更新 w→w\\rightarroww→计算梯度 ∂L∂wk→\\frac{\\partial L}{\\partial w_k}\\rightarrow∂wk​∂L​→更新 w→...→w\\rightarrow...\\rightarroww→...→达到收敛条件，得到训练后参数 www 同样的，将训练好的CRF模型用于解码问题也可以采用维特比算法，此处将不再赘述。 1.维基百科中文：马尔科夫链 ↩2.wikipedia: Viterbi algorithm ↩3.wikipedia: Conditional_random_field ↩","link":"/posts/568ec988/"},{"title":"算法&#x2F;算法启蒙","text":"写在前面：“学好程序与算法，走遍天下都不怕。” 枚举 背景 找不到合适的数学公式和技巧 （改良后）枚举复杂度不是特别大 通常用于找到一种情况使之满足题意的题目 配合假设法找到目标情形：假币问题 技巧 跳跃枚举法：跳过对没有必要的情况的枚举 局部枚举法：枚举局部，剩下的由该局部确定。例如熄灯问题 递归 作用 替代多重循环，如：n皇后问题。 这种类型往往要运用到一个全局/静态变量来存储前面算过的结果，譬如n皇后就用到了一个全局数组来保存每一行的皇后拜访情况。全局/静态变量的好处就在于所有递归函数共享成果，就像递推迭代一样，每一步会影响下一步。 递归函数形式：T function( T f(n) )，函数意义：在前n-1步已经完成的情况下决定如何走第n步，往往第一个被调用的function参数为0或1（然后依次调用 111 ~ n0n_0n0​） 解决实质是递归形式的问题 有些问题本身就是递归定义的，比如不少表达式就是递归定义的：逆波兰，四则运算。逆波兰直接递归调用自身定义，四则运算则包含项，因子和表达式自身等多个概念，是一种间接递归调用自身定义 函数，数列的递推公式 关键是搞清楚问题是怎样递归定义的，可以借助画图，写代数式的办法捋清楚。 将问题分解为规模更小的子问题来求解 如何来分解？ “n=1+(n-1)”法 比方说要解决一个规模为n的问题，先找到解决该问题的第一步怎么做，然后再把剩下的问题解决，剩下的问题规模刚好是n-1且解决过程自相似，可以用上递归n-1。e.g.台阶问题 “n=(n-1)+1”法 先解决n-1问题，再将最后一步完善,e.g.汉诺塔问题 与多重循环不同，该方法第一个调用的function参数往往时n0总规模 与分治不同，分治往往偏向于均分，而且多了一步综合，不过分治与递归又可以相互补充 附注 atof（）函数，将浮点串转变为浮点数 cin.peek（）函数，提前预知输入而非读取 浮点数的比较引入eps 二分 简介 对一个待求系统（通常为有序系统），每次都均分为两半，通过判断“砍掉”其中“无用”的一半，对剩下的一半用同样的方法处理，直到得出结论。 作用 二分查找 不仅限于查找某一个具体的数，还可以查找符合某种要求的数（通常满足一定的大小关系） 二分法求方程根 分治 基本思想 将一个问题拆分成两个或两个以上规模更小的问题，然后将小问题分别解决或只解决部分问题，最后综合处理一次。 一般模式：分划，局部处理，综合处理（分治 | 归并） 常常与递归思想结合 作用：使规模缩小，提高算法效率（想想：不断地递归并分治，使得规模不断二分） 应用举例：基于分治策略的快速排序和归并排序 附注 &quot; x &amp; 1 &quot; 表达式判别x奇偶性 快速幂算法 动态规划 背景 问题具有最优子结构 问题的最优解所包含的子问题的解也是最优的 问题具有无后效性 当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取何种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 单纯的递归会导致大量子问题 重复计算 时 思路方法 原问题分解为子问题 一些问题的求解归结于它的子问题的求解，且子问题与原问题类似，只是规模减小。 子问题一旦解决即被保存（通常存入一个多维数组）。 确定状态 “状态”简介：在用动态规划解题时，我们往往将和子问题相 关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。 状态空间与时间复杂度：整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。（在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。） 用动态规划解题，经常碰到的情况是，K个整型变量能 构成一个状态（如数字三角形中的行号和列号这两个变量 构成“状态”）。如果这K个整型变量的取值范围分别是 N1, N2, ……Nk，那么，我们就可以用一个K维的数组 array[N1] [N2]……[Nk]来存储各个状态的“值”。这个 “值”未必就是一个整数或浮点数，可能是需要一个结构 才能表示的，那么array就可以是一个结构数组。一个 “状态”下的“值”通常会是一个或多个子问题的解。 确定一些初始状态（边界状态）的值 确定状态转移方程 将第一步 分解 得到的原问题与子问题的关系用数学符号语言表述出来，即实现状态之间的转移关系。 动规程序写法 记忆递归型 递归函数+记忆数组 “人人为我”递推型 1,2,3,…,n-1 =&gt; n 递推到“n”时“n”仍未被求出，前面已被求出的状态值用于求“n”的状态值 “我为人人”递推型 n =&gt; k (k&gt;n) 递推到“n”时“n”已经被求出，n将用于求后面的状态值 递归写法 递推写法 难度 直观简便 较复杂，可能需要结合图形理解 内存占用 较大，有爆栈风险 小，还可以用滚动数组进一步节省空间 动规中递归法向递推法转化的一般方法： 递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值 是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。 常见分解（状态转移）方法归纳 多分类讨论， 想想解决原问题等同于解决什么和什么。有时候要经过多层分解才能够得到与原问题结构相同的子问题。 “n=(n-1)+1”型与&quot;n=1+(n-1)&quot;型（与 递归 的 先走一步 思想又异曲同工之妙，n为问题规模） &quot;F(i,j,k)=F(i-1,j,k)+F(i,j-1,k)+F(i,j,k-1)&quot;型（这里拿 三维 的情况举例，其他维度的状态转移方程与此大同小异） &quot;F(m,n)=A, A=G( F(m-1,n),F(m,n-1) )&quot;型，间接递归 附注 数字三角形题目启示录： ①空间优化：滚动数组（通过覆盖今后无用的旧有数据空间的方法来压缩空间），降维，关注不必要的存储空间以及运行过程中变得可以丢弃的数据。②递归化递推：逆向思维。 深度优先搜索 关键词：回溯 标记(判重) 剪枝 图 状态 简介 从某个起点开始每走一步就做一个标记，然后下一步随便选择一个没有走过的节点，走不通则回退到上一步重新选择。这种走法总是试图“走的更远”。 重要概念 图（连通图，非连通图，子图，极大连通子图…） 图上节点（或者某抽象的状态：e.g.譬如每个棋局也可以看作是一个图节点） 图上边：节点之间的联系 图路径（枝） 图的表示 邻接矩阵：L[i][j] 用一个二维数组（元素可以是一个结构，存储诸如 连通与否 路径长度 权值 方向 等内容）表示节点i与节点j之间的联系。遍历复杂度：O(n^2),n表示节点 。 邻接表：S[k] 用一个一维数组（元素可以是一个结构，存储 邻接节点 以及诸如 路径长度 权值 方向 等内容）表示所有与节点k有关的边的信息。遍历复杂度：O(n+e),n表示节点数，e表示边数。 当e特别大而接近n^2时，邻接表就失去了优势变得和邻接矩阵差不多了。 其他表示方法：具体问题具体分析。 剪枝 可行性剪枝：每搜索一个节点后发现不满足题目要求则直接回溯防止沿着这条路径继续错误地走下去。 最优性剪枝：每搜索一个节点后都对当前路径的最优性进行检验，若当前以及可以判明不是最优路径或者说接着走下去一定不是最优路径则直接回溯。 与整体最优解比较来剪枝 保存中间结果用于最优性剪枝 ：如果到达某个状态A时，发现前面曾经也到达过A，且前面那次到达A所花代价更少，则剪枝。这要求保存到达状态A的到目前为止的最少代价。 （ 对每个节点都开辟存储空间来存放以该节点为终点的当前最优解，每次搜索到一个节点就将该最优值与新值比较，原值更优则剪枝，新值更优则更新该最优值） 注意：“最优”的决定要素可能不止一项，还可能是多元因素，如：ROADS问题中有费用和路程两个因素。剪枝时要考虑控制单一变量。 广度优先搜索 简介 从节点开始层次遍历（用队列）整个图。 特点 搜到的路径一定是最短的。 占用空间较大，尤其是目标节点层次很高时。 如果题目要求路径则每次入队的元素都要包含有指向父节点的“指针”。要注意，STL中的queue容器中元素一旦出队则会导致对象的丢失，因此需要自己动手编写一个保证父节点不会丢失的队列。 一般模式 广度优先搜索算法如下：（用QUEUE） 把初始节点S0放入Open表中 如果Open表为空，则问题无解，失败退出 把Open表的第一个节点取出放入Closed表，并记该节点为n 考察节点n是否为目标节点。若是，则 得到问题的解，成功退出 若节点n不可扩展，则转第(2)步 扩展节点n，将其不在Closed表和 Open表中的子节点(判重）放入Open表的尾 部，如有必要为每一个子节点设置指向父节点的指针 (或记录节点的层次），然后转第(2)步。 DSP vs BSP 深搜 广搜 适用范围 几乎任何问题 状态表示比较简单，求最优策略的问题 优点 空间占用较少 找到的解一定路径最短 缺点 运气不好时耗时长，甚至无法在多项式时间内求解，需要剪枝优化 目标节点层次高时搜索过程将产生许多无用节点，搜索效率低且占用空间大，需要优化存储方式 结构 栈（递归） 队列 根据题目要求凭借自己的经验和对两个搜索的熟练程度做出选择 贪心 简介 只考虑当前最优，通过局部最优达到整体最优的策略 贪心算法需要证明其正确性 贪心检验：替换法 假设最优序列为{ai}，贪心得到的序列为{bi}，则只需要证明{ai}={bi}即可证明贪心得到的是整体最优。 必要时先将ai按照bi（贪心策略得到的序列）的方式排好序 然后从i=1开始逐个考虑能否将ai替换为bi而不影响ai后面序列的选择。如果对于所有i均可替换，则{ai}={bi}。 数学归纳法 附注 一类常见的应用贪心策略的题：区间题 解决思路：关注端点，合理排序，顺序处理","link":"/posts/8ee1a4a1/"},{"title":"技术&#x2F;备忘&#x2F;Hexo icarus 博客维护","text":"基本指令 基本指令123456789/*npm指令*/npm install/uninstall xxx//执行package.json中定义的脚本npm run server/*hexo指令*/hexo cl &amp;&amp; hexo g &amp;&amp; hexo s //清理，生成，本地服务器hexo d //部署hexagon -l //查看插件 更多 Hexo 指令 传送门 Front-matter 参数 描述 默认值 layout 布局 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） excerpt 摘要 widget icarus 主题空间 标签插件 Embed 增强了 markdown 的功能的一系列插件 info: embed 语法不要包裹在反引号中，且冒号后面不要空格！！ 官方文档 官方插件文档 其他插件 探宝方法：hexo.io 搜索 embed 自己做：&lt;embed&gt; hexo-github-card hexo-pdf hexo-tag-bilibili hexo-tag-douban hexo-tag-bootstrap 插件 Components textcolor - Convey meaning through color with a handful of emphasis utility classes. button - Inserts a button with target links, text and specified color. ** text label - Inserts a label with text and specified color. pill - Inserts a label with text and specified color. ** text badge - Inserts a badge with text. alert - Inserts alert messages with text and specified color. card - Add a card control ** carddeck - use with cards to combine multiples ** cardgroup - similar to carddeck jumbo - jumbotron carousel - carousel tag - each img within will create a new “slide” row - add a grid row col - add a column within a grid row 使用示例 ！🐱‍🏍传送门🐱‍🏍 举亿个栗子 渲染效果因css而异 badge text alert 块级 属性：waring danger success info Best check yo self, you’re not looking too good. Change a few things up and try submitting again. You successfully read this important alert message. This alert needs your attention, but it’s not super important. textcolor （暂无css渲染） Fusce dapibus, tellus ac cursus commodo, tortor mauris nibh. Nullam id dolor id nibh ultricies vehicula ut id elit. Duis mollis, est non commodo luctus, nisi erat porttitor ligula. Maecenas sed diam eget risus varius blandit sit amet non magna. Etiam porta sem malesuada magna mollis euismod. Donec ullamcorper nulla non metus auctor fringilla. 行内label 支持属性 default warning success danger primary info default warinng success danger primary info 行内btn 支持属性 primary success warning danger info btn btn btn btn btn btn 插入HTML来增强阅读体验 Bulma 是一个CSS框架。查看Bulma文档。 CSS 框架不包含js，涉及点击事件需要自行处理！ Note 不用js的情况下适合的组件有：button，dropdown，message Click me Overview Modifiers Grid Form Elements Components Layout More Hover me You can insert any type of content within the dropdown menu. 博客备份迁移","link":"/posts/6e7bdc/"},{"title":"技术&#x2F;开发&#x2F;AndroidLearning","text":"Android Studio 入坑笔记 Android Studio 自动创建 resource id 失败 重启 AS。 Sync with file system 同步一下？ 查看 R.java 中的 id 。Project 下依次打开app–&gt;build–&gt;generated–&gt;source–&gt;r–&gt;debug，在debug中的两个选项的子文件中分别有有一个R文件，既我们要找的R.java文件。（或者直接shift+shift查找R.java","link":"/posts/fae5c3cd/"},{"title":"技术&#x2F;工具&#x2F;IDEA 学习笔记","text":"IDEA基础功能概览： shortcut(edit, 代码片段, 功能), 版本控制(VCS: git, github, local history) Debug, javadoc generator, database, web deployment project&amp;module 等概念, 模板, 项目结构查询管理 Tips 代码段：main sout标准输出 soutv输出变量，soutm输出方法名，soutp输出命令行参数 变量名.sout输出变量 iter增强型for循环 引用名.for 迭代指定引用类型 实例名.fori顺序遍历 xxx.forr倒序遍历 ifn --“if xxx is null”, inn --“if not null” xxx.nn, xxx.ifn JavaLea 条件断点 --右键断点处 ctrl+u 查看表达式的值 Tools javadoc generator: Local: zh_CN; Other command line args: encoding UTF-8 -charset UTF-8 IDE 常用快捷键对照表（原始来源: https://www.jianshu.com/p/6267a7d76018 ) 操作 eclipse IDEA Visual Studio Code Sublime 编辑 Editing 格式化代码 Format Code Ctrl+Shift+F Ctrl+Shift+L Shift+Alt+F 无 删除行 Delete Line Ctrl+D Ctrl+Y Ctrl+Shift+K Ctrl+Shift+K 复制行 Copy Line Ctrl+C Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+Shift+Up/Down Ctrl+D Alt+Shift+Up/Down Ctrl+Shift+D 移动行 Move Line Alt+Up/Down Alt+Shift+Up/Down Alt+Up/Down Ctrl+Shift+Up/Down 换行 New Line Shift+Enter Shift+Enter Shift+Enter Ctrl+Enter 插入上行 Insert Line Above Ctrl+Shift+Enter Ctrl+Alt+Enter Ctrl+Shift+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+\\ Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Alt+Shift+Up/Down Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 优化导包 Optimize Imports Ctrl+Shift+O Ctrl+Alt+O 代码提示 Code Assist Alt+/ Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Alt+/比较low Ctrl+Shift+Enter 快速修复 Quick Fix Ctrl+1 Alt+Enter Quick Access Ctrl+3 Double Shift 参数信息 Parameter Info Alt+Shift+/还不如 Alt+/ Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Alt+Shift+N Ctrl+N 激活编辑器 Active Editor F12 Esc 全部小写 Ctrl+Shift+Y 全部大写 Ctrl+Shift+X 导航 Navigation 上/下一个Tab Ctrl+PgUp/PgDn Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Alt+Left/Right Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Q Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+L Ctrl+G 大纲/结构 Outline/Structure Ctrl+O Ctrl+F12 查看类层级 Type Hierarchy Ctrl+T 查看最近文件 Recent File Ctrl+E Ctrl+F6 Ctrl+E 跳到文件 Go To File Ctrl+Shift+N 切换视图 Switch View Ctrl+F7 重构 Refator 重命名 Rename Alt+Shift+R Shift+F6 提取变量 Extract Variable Alt+Shift+L 提取方法 Extract Method Alt+Shift+M 搜索 Find 查找下一个 Ctrl+K 查找上一个 Ctrl+Shfit+K 全局搜索 Ctrl+H","link":"/posts/5a1e79ff/"},{"title":"技术&#x2F;备忘&#x2F;CMD 指令备忘","text":"CMD 指令备忘 Process 类 tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process","link":"/posts/369ceeb5/"},{"title":"技术&#x2F;备忘&#x2F;IDE&amp;Editor Shortcuts Query","text":"各大 IDE &amp; Editor 快捷键对照表 操作 IntelliJ IDEA Visual Studio Code Visual Studio 编辑 Editing 格式化代码 Format Code Ctrl+Shift+L Shift+Alt+F 删除行 Delete Line Ctrl+Y Ctrl+Shift+K 选中行 Select Line Ctrl+L 复制行 Copy Line Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+D Alt+Shift+Up/Down 移动行 Move Line Alt+Shift+Up/Down Alt+Up/Down 换行 New Line Shift+Enter Shift+Enter 插入上行 Insert Line Above Ctrl+Alt+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 选择相同内容 Alt+J Ctrl+D 优化导包 Optimize Imports Ctrl+Alt+O 代码提示 Code Assist Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Shift+Enter 快速修复 Quick Fix Alt+Enter Quick Access Double Shift 参数信息 Parameter Info Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Ctrl+N 激活编辑器 Active Editor Esc 全部小写 全部大写 导航 Navigation 上/下一个Tab Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+G Ctrl+G 大纲/结构 Outline/Structure Ctrl+F12 查看类层级 Type Hierarchy 查看最近文件 Recent File Ctrl+E 跳到文件 Go To File 切换视图 Switch View 重构 Refator 重命名 Rename Shift+F6 提取变量 Extract Variable 提取方法 Extract Method 搜索 Find 查找 Find Ctrl+F Ctrl+L Ctrl+F 查找下一个 查找上一个 全局搜索","link":"/posts/fde8aecf/"},{"title":"技术&#x2F;备忘&#x2F;小技巧手册","text":"每天一个避坑小技巧 解决网站元素（例如图片）加载不出来的方法 浏览器下审查该元素的URL地址，然后在搜索他的域名对应的地址（https://tools.ipip.net/domain.php） 将域名解析 “xxx.xxx.xxx.xxx 域名” 加入到hosts文件中（一般在 %SystemRoot%\\system32\\drivers\\etc\\ 目录下） cmd 下 ipconfig \\flushdns 刷新试试 刷新浏览器查看效果 SSR 解决端口占用问题： 法一：在 SSR 选项设置里改变端口 法二：taskkill /pid xxx -f","link":"/posts/fac7f463/"},{"title":"技术&#x2F;笔记&#x2F;《第一行代码：Android》读书笔记 (一)","text":"Android Kotlin 读书笔记 简介 \"《第一行代码：Android 3rd》第一章到第五章的读书笔记，讲了AS的基本使用方法和Android项目结构，四大组件之一的Activity，以及各种UI控件的编写，还收录了本书中涉及的Kotlin的语法特性\" 第一章 开启征程（概要） 项目结构与目录：page 17 - page 19 Log 方法与 Logcat 的完美结合 第二章 Kotlin 语法糖 同《Kotlin 学习笔记》一同食用更佳！ 《第一行》中出现的 Kotlin 特性预览表 主次构造函数 参数默认值 键值对传参 字符串内嵌表达式 init {}, constructor () {} fun xxx(str: String = &quot;&quot;) {...} xxx(str = &quot;...&quot;) &quot;${value}&quot; 标准函数 Lambda 表达式 空指针检查 函数式 API let, run, apply, with {para -&gt; ...}, {it.toString()} ? ?. !!. ?: map.maxby {/*Lambda*/} 容器初始化 数据类 单例类 循环遍历 listOf(), mapOf(), setOf() data object for-in, until, downTo, step, l...r,容器遍历 分支控制 条件控制 “不变为先” 访问控制 when () {... -&gt; ...}, if-else 语句/表达式 is (instanceof), else val, var, open class &quot;public by default&quot; 类型强转 repeat 函数 运算符重载 延迟初始化 as, as? repeat(/*num*/) {/*Lambda*/} operator 关键字 lateinit 初始化判断 密封类（与when语句一同使用） 扩展函数 无用参数 ::($变量名).isInitialized sealed class fun ClassName.funcName(...) : ... {} 下划线_ 第三章 Activity！所见即所得 创建 Activity 创建和加载布局文件 layout 在 AndroidManifest.xml 中注册Activity 编写 Activity.kt 代码 （事件绑定，方法重写等） Activity 通信与切换 Intent 类 显式切换：Intent(上下文, 指定Activity 的 Class 类) 隐式切换：指定 action category，目标将会按照注册信息中的过滤条件响应 intent。 过滤条件：&lt;category&gt; &lt;action&gt; &lt;data&gt; 传参：.putExtra(), .getStringExtra() 启动方式：startActivity() //普通启动 startActivityForResult() //请求结果 - Activity 类 Result 结果 设置结果：setResult() 取回结果：override onActivityResult() Bundle 类 团队合作时用伴生类“静态方法”来启动 Activity 生命周期 返回栈的概念 思维导图 保存信息 Bundle 类型 onSaveInstanceState()，var savedInstanceState Activity 启动模式 standard 无检查，直接压栈 singleTop 检查栈顶 singleTask 解栈恢复 singleInstance 创建新栈 第四章 UI！！ 门面功夫 😃 控件 Widget 基本控件：TextView，EditView，Button，…… 自定义控件：编写class（注入布局，绑定事件）→\\rightarrow→ xml注册引入自定义控件 →\\rightarrow→ 引入控件 高级一点的控件：ListVIew, RecyclerView … 基本原理撇清楚 Inflater 的作用：将xml格式的布局文件解析转化成View的实例 findViewById() 返回布局中指定id的View实例, 在Activity类中直接使用findViewById()相当于在当前Activitiy所加载的布局中寻找对应的view，而使用view.findViewById()则指定了寻找的区域是view内 留意Kotlin自动类型推导机制的使用场合，方法 *第五章 手机平板要兼顾，探究Fragment 学习内容 Frag 生命周期，Frag 动态加载布局","link":"/posts/37a431d8/"},{"title":"技术&#x2F;语言&#x2F;C指针扫盲","text":"首先看看函数指针，函数名，以及它们分别与*和&amp;结合后的值 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); //puts(\"\\n接着我们尝试用上述变量调用函数:\"); //func(); //(*func)(); //(&amp;func)(); //(p_func)(); //(*p_func)(); return 0;} 执行结果 1234567func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC 可见func,*func,&amp;func,p_func,*p_func代表的值都是func()函数的地址 （ &amp;p_func是指针的地址 ） 再来看看将它们分别作为函数名的结果 程序清单 12345678910111213141516171819#include&lt;stdio.h&gt;void func(void){puts(\"成功调用\");};int main(){ void(*p_func)(void)=func; puts(\"func是函数名，p_func是指向该函数的指针，那么有:\"); printf(\"func=%p\\n*func=%p\\n&amp;func=%p\\ \\np_func=%p\\n*p_func=%p\\ \\n&amp;p_func=%p\",func,*func,&amp;func,p_func,\\ *p_func,&amp;p_func); puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} func，p_func，*p_func，*func，&amp;func作函数名 源程序 12345678 puts(\"\\n接着我们尝试用上述变量调用函数:\"); func(); (*func)(); (&amp;func)(); (p_func)(); (*p_func)(); return 0;} 编译运行结果 12345678910111213func是函数名，p_func是指向该函数的指针，那么有:func=004015C0*func=004015C0&amp;func=004015C0p_func=004015C0*p_func=004015C0&amp;p_func=0061FECC接着我们尝试用上述变量调用函数:成功调用成功调用成功调用成功调用成功调用 可见func，p_func，*p_func，*func，&amp;func作函数名均可以实现函数调用","link":"/posts/f1e4bda1/"},{"title":"技术&#x2F;语言&#x2F;Golang 避坑手册","text":"&quot;{&quot;的位置要注意 分号无 多变量声明： //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断 vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误 12345// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 默认值 并行特性：多个返回值，并行赋值 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： a = a++ // 这是不允许的，会出现变异错误 syntax error: unexpected ++ at end of statement ! Go 的自增，自减只能作为表达式使用，而不能用于赋值语句。 for each range loop !!! 函数闭包（同一个被赋予闭包函数的函数每次调用都会将匿名函数内的局部变量记忆下来） 12345678910111213141516package mainimport \"fmt\"func main() { add_func := add(1,2) fmt.Println(add_func(1,1)) fmt.Println(add_func(0,0)) fmt.Println(add_func(2,2))} // 闭包使用方法func add(x1, x2 int) func(x3 int,x4 int)(int,int,int) { i := 0 return func(x3 int,x4 int) (int,int,int){ i++ return i,x1+x2,x3+x4 }} := cannot be used globally!!! 全局变量和局部变量都有默认值 结构体与数组的匿名 append()必须要用它的返回值（原因很简单，其参数列表用的是值传递而不是指针传递） map必须要初始化（用make（）或者声明的时候直接赋值），否则只是个nil，无法对其进行赋值！！！？？ !!!GO没有隐式类型转换！！！需要灵活使用显示类型转换！ 将一个结构体赋值给一个接口变量可以想象成该接口成为了一个指向该结构体的“指针” 通道chan类型是“值相关”的，相同chan值描述同一个通道，chan用close（）关闭，）有点像file descriptor？ 两个并发线程时间前后关系不确定，同一个程序可能有不同结果 close一个chan后还能接收，不可发送","link":"/posts/c737d2b3/"},{"title":"技术&#x2F;语言&#x2F;Java&amp;Kotlin语法对照","text":"Java &amp; Kotlin 的语法片段对照 函数式 API Java 123456789101112//传入接口类型的实例（或继承了接口的匿名类）/* public interface Runnable { void Run(); } */new Thread(new Runnable() { @Override public void run() { //执行逻辑 }}).start() Kotlin 1234//传入Lambda表达式（单抽象的接口类型也可简化为Lambda表达式后传入）Thread { //执行逻辑}.start() 访问控制 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 Class 对象引用 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class","link":"/posts/7a368ad4/"},{"title":"技术&#x2F;语言&#x2F;JavaLearning","text":"2020-4-28 content: 对象与类，基本数据类型 int a, b; 则“a=b”表达式为int类型，不会自动转化为boolean类型 Java 的匿名内部类 Java12345678910111213//定义语法new 父类构造器（实参列表) | 实现接口() //必须继承一个父类或接口{ //匿名内部类的类体部分}/** * 规范： * 匿名类的声明是由java编译器自动派生自一个类实例创建表达式。 * 匿名类永远不能是抽象的。 * 匿名类总是隐式的final。 * 匿名类总是一个内部类；并且不能是static的。 */ 注意： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 内部类的class文件命名是：主类＋$＋内部类名 匿名类的class文件命名是：主类＋$＋(1,2,3…) class 对象 获取方式：有三种获得Class对象的方式： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class （类字面常量） 每个类的运行时的类型信息就是用Class对象表示的","link":"/posts/6374ed46/"},{"title":"技术&#x2F;语言&#x2F;LatexTikz","text":"Tikz 绘图学习笔记 注意事项: \\begin{tikzpicture} 环境下每一行命令结尾都要加分号; \\node, \\coordinate, \\draw 语法参考：https://zhuanlan.zhihu.com/p/84943429 \\node 描点, \\coordinate 拟点, \\draw 画线, \\fill 填充 参考网站: 路径与坐标：https://www.latexstudio.net/archives/51602.html node 控制：https://www.latexstudio.net/archives/51617.html 线条控制: https://www.latexstudio.net/archives/51622.html 示例代码: 12\\node at (A)[circle,fill,inner sep=1pt]{};% 点名 属性","link":"/posts/9b17222d/"},{"title":"技术&#x2F;语言&#x2F;Kotlin 学习笔记","text":"Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 $a 和 ${a.func()}我是真没话说。 完善的NULL检查机制 “!!, ?, ?:”（当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。方法是： “Type后 + ？”） 玩转for循环：可以方便的指定遍历的步长，范围。（ …, step, downTo, in, until) Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 支持二进制字面量，数值类型混入下划线增加语义性。 有些时候较小类型不会隐式转换成较大类型，需要手动调用 .toXXX() 来进行显示的类型转换。 和 golang 一样少了分号（这就是语法糖吗i了i了 if-else 语句与when语句等可以视为 表达式（可赋值 when 与 -&gt; 符号构成强大的分支控制。 完全抛弃基本数据类型改用对象数据类型“。 “fun xxx() = xxx” 这个语法糖结合 if else, when 等特性可以打出漂亮的组合拳。 class 继承的时候对继承的父类后面一般要加括号（因为 java 继承中必调用父类构造函数）且此构造函数必调用著构造函数。 Java 与 Kotlin 访问修饰符对照表 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 语法糖: 原生支持数据类、单例类 （自动完成 toString(), hashCode(), equals() 等方法） 数据类对比 Java-example12345678910111213141516171819202122232425262728public class Cellphone { String brand; double price; public Cellphone(String brand, double price) { this.brand = brand; this.price = price; } @Override public boolean equals(Object obj) { if (obj instanceof Cellphone) { Cellphone other = (Cellphone) obj; return other.brand.equals(brand) &amp;&amp; other.price == price; } return false; } @Override public int hashCode() { return brand.hashCode() + (int) price; } @Override public String toString() { return \"Cellphone(brand=\" + brand + \", price=\" + price + \")\"; }} Kotlin-example1data class Cellphone(val brand: String, val price: Double) //加一个data即可 单例类对比 Java-example12345678910111213141516public class Singleton { private static Singleton instance; private Singleton() {} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } public void singletonTest() { System.out.println(\"singletonTest is called.\"); }} Kotlin-example12345object Singleton { //只需要用object代替class即可 fun singletonTest() { println(\"singletonTest is called.\") } //这里相当于一个静态方法} Kotlin class 类 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class Kotlin 标准函数 一系列定义于 Standard.kt 里的函数 参照表 函数 特点 代码段 let() 调用let的对象作为Lamda的参数，返回最后一行 obj.let {(obj2 -&gt;) //obj2是obj} with() 传入对象作为Lambda的上下文，返回最后一行 with(obj) {//obj上下文} run() 调用run的对象作为Lamda的上下文，返回最后一行 obj.run {//obj上下文} apply() 调用apply的对象作为Lamda的上下文，返回原对象 obj.apply {//obj上下文} Kotlin “静态方法调用” 单例类 objetc {} 伴生类 companion object {} 顶层方法 fun xxx()，可以被任意Kotlin代码直接调用，文件名作为类还可以用于java静态方法调用 @JvmStatic 注释，只能加注在单例类方法或伴生类方法上，使其编译成java静态方法","link":"/posts/ec3dabc7/"}],"tags":[{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"搜索算法","slug":"搜索算法","link":"/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Command","slug":"Command","link":"/tags/Command/"},{"name":"踩坑","slug":"踩坑","link":"/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"}],"categories":[{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"备忘","slug":"技术/备忘","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%A4%87%E5%BF%98/"},{"name":"开发","slug":"技术/开发","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%8F%91/"},{"name":"笔记","slug":"技术/笔记","link":"/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"},{"name":"语言","slug":"技术/语言","link":"/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E8%A8%80/"},{"name":"工具","slug":"技术/工具","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"}]}